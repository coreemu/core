{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"CORE Documentation","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>CORE (Common Open Research Emulator) is a tool for building virtual networks. As an emulator, CORE builds a representation of a real computer network that runs in real time, as opposed to simulation, where abstract models are used. The live-running emulation can be connected to physical networks and routers. It provides an environment for running real applications and protocols, taking advantage of tools provided by the Linux operating system.</p> <p>CORE is typically used for network and protocol research, demonstrations, application and platform testing, evaluating networking scenarios, security studies, and increasing the size of physical test networks.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Efficient and scalable</li> <li>Runs applications and protocols without modification</li> <li>Drag and drop GUI</li> <li>Highly customizable</li> </ul>"},{"location":"architecture.html","title":"CORE Architecture","text":""},{"location":"architecture.html#main-components","title":"Main Components","text":"<ul> <li>core-daemon<ul> <li>Manages emulated sessions of nodes and links for a given network</li> <li>Nodes are created using Linux namespaces</li> <li>Links are created using Linux bridges and virtual ethernet peers</li> <li>Packets sent over links are manipulated using traffic control</li> <li>Provides gRPC API</li> </ul> </li> <li>core-gui<ul> <li>GUI and daemon communicate over gRPC API</li> <li>Drag and drop creation for nodes and links</li> <li>Can launch terminals for emulated nodes in running sessions</li> <li>Can save/open scenario files to recreate previous sessions</li> </ul> </li> <li>vnoded<ul> <li>Command line utility for creating CORE node namespaces</li> </ul> </li> <li>vcmd<ul> <li>Command line utility for sending shell commands to nodes</li> </ul> </li> </ul>"},{"location":"architecture.html#sessions","title":"Sessions","text":"<p>CORE can create and run multiple emulated sessions at once, below is an overview of the states a session will transition between during typical GUI interactions.</p> <p></p>"},{"location":"architecture.html#how-does-it-work","title":"How Does it Work?","text":"<p>The CORE framework runs on Linux and uses Linux namespacing for creating node containers. These nodes are linked together using Linux bridging and virtual interfaces. CORE sessions are a set of nodes and links operating together for a specific purpose.</p>"},{"location":"architecture.html#linux","title":"Linux","text":"<p>Linux network namespaces (also known as netns) is the primary technique used by CORE. Most recent Linux distributions have namespaces-enabled kernels out of the box. Each namespace has its own process environment and private network stack. Network namespaces share the same filesystem in CORE.</p> <p>CORE combines these namespaces with Linux Ethernet bridging to form networks. Link characteristics are applied using Linux Netem queuing disciplines. Nftables provides Ethernet frame filtering on Linux bridges. Wireless networks are emulated by controlling which interfaces can send and receive with nftables rules.</p>"},{"location":"architecture.html#open-source-project-and-resources","title":"Open Source Project and Resources","text":"<p>CORE has been released by Boeing to the open source community under the BSD license. If you find CORE useful for your work, please contribute back to the project. Contributions can be as simple as reporting a bug, dropping a line of encouragement, or can also include submitting patches or maintaining aspects of the tool.</p>"},{"location":"ctrlnet.html","title":"CORE Control Network","text":""},{"location":"ctrlnet.html#overview","title":"Overview","text":"<p>The CORE control network allows the virtual nodes to communicate with their host environment. There are two types: the primary control network and auxiliary control networks. The primary control network is used mainly for communicating with the virtual nodes from host machines and for master-slave communications in a multi-server distributed environment. Auxiliary control networks have been introduced to for routing namespace hosted emulation software traffic to the test network.</p>"},{"location":"ctrlnet.html#activating-the-primary-control-network","title":"Activating the Primary Control Network","text":"<p>Under the Session Menu, the Options... dialog has an option to set a control network prefix.</p> <p>This can be set to a network prefix such as 172.16.0.0/24. A bridge will be created on the host machine having the last address in the prefix range (e.g. 172.16.0.254), and each node will have an extra ctrl0 control interface configured with an address corresponding to its node number (e.g. 172.16.0.3 for n3.)</p> <p>A default for the primary control network may also be specified by setting the controlnet line in the /opt/core/etc/core.conf configuration file which new sessions will use by default. To simultaneously run multiple sessions with control networks, the session option should be used instead of the core.conf default.</p> <p>Note</p> <p>If you have a large scenario with more than 253 nodes, use a control network prefix that allows more than the suggested /24, such as /23 or greater.</p> <p>Note</p> <p>Running a session with a control network can fail if a previous session has set up a control network and the its bridge is still up. Close the previous session first or wait for it to complete. If unable to, the core-daemon may need to be restarted and the lingering bridge(s) removed manually.</p> <pre><code># Restart the CORE Daemon\nsudo /etc/init.d core-daemon restart\n\n# Remove lingering control network bridges\nctrlbridges=`brctl show | grep b.ctrl | awk '{print $1}'`\nfor cb in $ctrlbridges; do\n  sudo ifconfig $cb down\n  sudo brctl delbr $cb\ndone\n</code></pre> <p>Note</p> <p>If adjustments to the primary control network configuration made in /opt/core/etc/core.conf do not seem to take affect, check if there is anything set in the Session Menu, the Options... dialog. They may need to be cleared. These per session settings override the defaults in /opt/core/etc/core.conf.</p>"},{"location":"ctrlnet.html#control-network-in-distributed-sessions","title":"Control Network in Distributed Sessions","text":"<p>When the primary control network is activated for a distributed session, a control network bridge will be created on each of the slave servers, with GRE tunnels back to the master server's bridge. The slave control bridges are not assigned an address. From the host, any of the nodes (local or remote) can be accessed, just like the single server case.</p> <p>In some situations, remote emulated nodes need to communicate with the host on which they are running and not the master server. Multiple control network prefixes can be specified in the either the session option or /opt/core/etc/core.conf, separated by spaces and beginning with the master server. Each entry has the form \"server:prefix\". For example, if the servers core1,core2, and core3  are assigned with nodes in the scenario and using /opt/core/etc/core.conf instead of the session option.</p> <pre><code>controlnet=core1:172.16.1.0/24 core2:172.16.2.0/24 core3:172.16.1.0/24\n</code></pre> <p>Then, the control network bridges will be assigned as follows:</p> <ul> <li>core1 = 172.16.1.254 (assuming it is the master server),</li> <li>core2 = 172.16.2.254</li> <li>core3 = 172.16.3.254</li> </ul> <p>Tunnels back to the master server will still be built, but it is up to the user to add appropriate routes if networking between control network prefixes is desired. The control network script may help with this.</p>"},{"location":"ctrlnet.html#control-network-script","title":"Control Network Script","text":"<p>A control network script may be specified using the controlnet_updown_script option in the /opt/core/etc/core.conf file. This script will be run after the bridge has been built (and address assigned) with the first argument being the name of the bridge, and the second argument being the keyword \"startup\". The script will again be invoked prior to bridge removal with the second argument being the keyword \"shutdown\".</p>"},{"location":"ctrlnet.html#auxiliary-control-networks","title":"Auxiliary Control Networks","text":"<p>Starting with EMANE 0.9.2, CORE will run EMANE instances within namespaces. Since it is advisable to separate the OTA traffic from other traffic, we will need more than single channel leading out from the namespace. Up to three auxiliary control networks may be defined. Multiple control networks are set up in /opt/core/etc/core.conf file. Lines controlnet1, controlnet2 and controlnet3 define the auxiliary networks.</p> <p>For example, having the following /opt/core/etc/core.conf:</p> <pre><code>controlnet = core1:172.17.1.0/24 core2:172.17.2.0/24 core3:172.17.3.0/24\ncontrolnet1 = core1:172.18.1.0/24 core2:172.18.2.0/24 core3:172.18.3.0/24\ncontrolnet2 = core1:172.19.1.0/24 core2:172.19.2.0/24 core3:172.19.3.0/24\n</code></pre> <p>This will activate the primary and two auxiliary control networks and add interfaces ctrl0, ctrl1, ctrl2 to each node. One use case would be to assign ctrl1 to the OTA manager device and ctrl2 to the Event Service device in the EMANE Options dialog box and leave ctrl0 for CORE control traffic.</p> <p>Note</p> <p>controlnet0 may be used in place of controlnet to configure the primary control network.</p> <p>Unlike the primary control network, the auxiliary control networks will not employ tunneling since their primary purpose is for efficiently transporting multicast EMANE OTA and event traffic. Note that there is no per-session configuration for auxiliary control networks.</p> <p>To extend the auxiliary control networks across a distributed test environment, host network interfaces need to be added to them. The following lines in /opt/core/etc/core.conf will add host devices eth1, eth2 and eth3 to controlnet1, controlnet2, controlnet3:</p> <pre><code>controlnetif1 = eth1\ncontrolnetif2 = eth2\ncontrolnetif3 = eth3\n</code></pre> <p>Note</p> <p>There is no need to assign an interface to the primary control network because tunnels are formed between the master and the slaves using IP addresses that are provided in servers.conf.</p> <p>Shown below is a representative diagram of the configuration above.</p> <p></p>"},{"location":"devguide.html","title":"CORE Developer's Guide","text":""},{"location":"devguide.html#overview","title":"Overview","text":"<p>The CORE source consists of several programming languages for historical reasons. Current development focuses on the Python modules and daemon. Here is a brief description of the source directories.</p> Directory Description daemon Python CORE daemon/gui code that handles receiving API calls and creating containers docs Markdown Documentation currently hosted on GitHub man Template files for creating man pages for various CORE command line utilities netns C program for creating CORE containers"},{"location":"devguide.html#getting-started","title":"Getting started","text":"<p>To setup CORE for develop we will leverage to automated install script.</p>"},{"location":"devguide.html#install-the-development-environment","title":"Install the Development Environment","text":"<p>The current recommended development environment is Ubuntu 22.04. This section covers a complete example for installing CORE on a clean install. It will help setup CORE in development mode, OSPF MDR, and EMANE.</p> <pre><code># install system packages\nsudo apt-get update -y\nsudo apt-get install -y ca-certificates git sudo wget tzdata libpcap-dev libpcre3-dev \\\n    libprotobuf-dev libxml2-dev protobuf-compiler unzip uuid-dev iproute2 iputils-ping \\\n    tcpdump\n\n# install core\ncd ~/Documents\ngit clone https://github.com/coreemu/core\ncd core\n./setup.sh\nsource ~/.bashrc\ninv install -d\n\n# install emane\ncd ~/Documents\nwget https://adjacentlink.com/downloads/emane/emane-1.5.1-release-1.ubuntu-22_04.amd64.tar.gz\ntar xf emane-1.5.1-release-1.ubuntu-22_04.amd64.tar.gz\ncd emane-1.5.1-release-1/debs/ubuntu-22_04/amd64\nsudo apt-get install -y ./openstatistic*.deb ./emane*.deb ./python3-emane_*.deb\n\n# install emane python bindings\ncd ~/Documents\nwget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.6/protoc-3.19.6-linux-x86_64.zip\nmkdir protoc\nunzip protoc-3.19.6-linux-x86_64.zip -d protoc\ngit clone https://github.com/adjacentlink/emane.git\ncd emane\ngit checkout v1.5.1\n./autogen.sh\n./configure --prefix=/usr\ncd src/python\nPATH=~/Documents/protoc/bin:$PATH make\nsudo /opt/core/venv/bin/python -m pip install .\n</code></pre>"},{"location":"devguide.html#pre-commit","title":"pre-commit","text":"<p>pre-commit hooks help automate running tools to check modified code. Every time a commit is made python utilities will be run to check validity of code, potentially failing and backing out the commit. These changes are currently mandated as part of the current CI, so add the changes and commit again.</p>"},{"location":"devguide.html#running-core","title":"Running CORE","text":"<p>You can now run core as you normally would, or leverage some of the invoke tasks to conveniently run tests, etc.</p> <pre><code># run core-daemon\nsudo core-daemon\n\n# run gui\ncore-gui\n\n# run mocked unit tests\ncd &lt;CORE_REPO&gt;\ninv test-mock\n</code></pre>"},{"location":"devguide.html#linux-network-namespace-commands","title":"Linux Network Namespace Commands","text":"<p>CORE includes its own set of tools for instantiating and configuring network namespace containers. This section describes these tools.</p>"},{"location":"devguide.html#vnoded","title":"vnoded","text":"<p>The vnoded daemon is the program used to create a new namespace, and listen on a control channel for commands that may instantiate other processes. This daemon runs as PID 1 in the container. It is launched automatically by the CORE daemon. The control channel is a UNIX domain socket usually named /tmp/pycore.23098/n3, for node 3 running on CORE session 23098, for example. Root privileges are required for creating a new namespace.</p>"},{"location":"devguide.html#vcmd","title":"vcmd","text":"<p>The vcmd program is used to connect to the vnoded daemon in a Linux network namespace, for running commands in the namespace. The CORE daemon uses the same channel for setting up a node and running processes within it. This program has two required arguments, the control channel name, and the command line to be run within the namespace. This command does not need to run with root privileges.</p> <p>When you double-click on a node in a running emulation, CORE will open a shell window for that node using a command such as:</p> <pre><code>gnome-terminal -e vcmd -c /tmp/pycore.50160/n1 -- bash\n</code></pre> <p>Similarly, the IPv4 routes Observer Widget will run a command to display the routing table using a command such as:</p> <pre><code>vcmd -c /tmp/pycore.50160/n1 -- /sbin/ip -4 ro\n</code></pre>"},{"location":"devguide.html#core-cleanup-script","title":"core-cleanup script","text":"<p>A script named core-cleanup is provided to clean up any running CORE emulations. It will attempt to kill any remaining vnoded processes, kill any EMANE processes, remove the :file:<code>/tmp/pycore.*</code> session directories, and remove any bridges or nftables rules. With a -d option, it will also kill any running CORE daemon.</p>"},{"location":"devguide.html#netns-command","title":"netns command","text":"<p>The netns command is not used by CORE directly. This utility can be used to run a command in a new network namespace for testing purposes. It does not open a control channel for receiving further commands.</p>"},{"location":"devguide.html#other-useful-commands","title":"Other Useful Commands","text":"<p>Here are some other Linux commands that are useful for managing the Linux network namespace emulation.</p> <pre><code># view the Linux bridging setup\nip link show type bridge\n# view the netem rules used for applying link effects\ntc qdisc show\n# view the rules that make the wireless LAN work\nnft list ruleset\n</code></pre>"},{"location":"distributed.html","title":"CORE - Distributed Emulation","text":""},{"location":"distributed.html#overview","title":"Overview","text":"<p>A large emulation scenario can be deployed on multiple emulation servers and controlled by a single GUI. The GUI, representing the entire topology, can be run on one of the emulation servers or on a separate machine.</p> <p>Each machine that will act as an emulation will require the installation of a distributed CORE package and some configuration to allow SSH as root.</p>"},{"location":"distributed.html#core-configuration","title":"CORE Configuration","text":"<p>CORE configuration settings required for using distributed functionality.</p> <p>Edit /opt/core/etc/core.conf or specific configuration file being used.</p> <pre><code># uncomment and set this to the address that remote servers\n# use to get back to the main host, example below\ndistributed_address = 129.168.0.101\n</code></pre>"},{"location":"distributed.html#emane-specific-configurations","title":"EMANE Specific Configurations","text":"<p>EMANE needs to have controlnet configured in core.conf in order to startup correctly. The names before the addresses need to match the names of distributed servers configured.</p> <pre><code>controlnet = core1:172.16.1.0/24 core2:172.16.2.0/24 core3:172.16.3.0/24 core4:172.16.4.0/24 core5:172.16.5.0/24\nemane_event_generate = True\n</code></pre>"},{"location":"distributed.html#configuring-ssh","title":"Configuring SSH","text":"<p>Distributed CORE works using the python fabric library to run commands on remote servers over SSH.</p>"},{"location":"distributed.html#remote-gui-terminals","title":"Remote GUI Terminals","text":"<p>You need to have the same user defined on each server, since the user used for these remote shells is the same user that is running the CORE GUI.</p> <p>Edit -&gt; Preferences... -&gt; Terminal program:</p> <p>Currently recommend setting this to xterm -e as the default gnome-terminal will not work.</p> <p>May need to install xterm if, not already installed.</p> <pre><code>sudo apt install xterm\n</code></pre>"},{"location":"distributed.html#distributed-server-ssh-configuration","title":"Distributed Server SSH Configuration","text":"<p>First the distributed servers must be configured to allow passwordless root login over SSH.</p> <p>On distributed server: <pre><code># install openssh-server\nsudo apt install openssh-server\n\n# open sshd config\nvi /etc/ssh/sshd_config\n</code></pre></p> <p>Modify the following settings: <pre><code># verify these configurations in file\nPermitRootLogin yes\nPasswordAuthentication yes\n\n# if desired add/modify the following line to allow SSH to\n# accept all env variables\nAcceptEnv *\n\n# if you are going to need more than 10 nodes on the server\n# change this setting, as it defaults to 10\nMaxSessions 10\n</code></pre></p> <p>Restart the sshd daemon: <pre><code>sudo systemctl restart sshd\n</code></pre></p> <p>On master server:</p> <pre><code># install package if needed\nsudo apt install openssh-client\n\n# generate ssh key if needed\nssh-keygen -o -t ed25519 -b 4096 -f ~/.ssh/core\n\n# copy public key to authorized_keys file\nssh-copy-id -i ~/.ssh/core root@server\n\n# configure fabric to use the core ssh key\nsudo vi /etc/fabric.yml\n\n# set configuration\nconnect_kwargs: {\"key_filename\": \"/home/user/.ssh/core\"}\n</code></pre> <p>On distributed server:</p> <pre><code># open sshd config\nvi /etc/ssh/sshd_config\n\n# change configuration for root login to without password\nPermitRootLogin without-password\n\n# restart sshd\nsudo systemctl restart sshd\n</code></pre>"},{"location":"distributed.html#fabric-config-file","title":"Fabric Config File","text":"<p>Make sure the value used below is the absolute path to the file generated above ~/.ssh/core\"</p> <p>Add/update the fabric configuration file /etc/fabric.yml:</p> <pre><code>connect_kwargs: { \"key_filename\": \"/home/user/.ssh/core\" }\n</code></pre>"},{"location":"distributed.html#add-emulation-servers-in-gui","title":"Add Emulation Servers in GUI","text":"<p>Within the core-gui navigate to menu option:</p> <p>Session -&gt; Servers...</p> <p>Within the dialog box presented, add or modify an existing server if present to use the name, address, and port for the a server you plan to use.</p> <p>Server configurations are loaded and written to in a configuration file for the GUI.</p>"},{"location":"distributed.html#assigning-nodes","title":"Assigning Nodes","text":"<p>The user needs to assign nodes to emulation servers in the scenario. Making no assignment means the node will be emulated on the master server In the configuration window of every node, a drop-down box located between the Node name and the Image button will select the name of the emulation server. By default, this menu shows (none), indicating that the node will be emulated locally on the master. When entering Execute mode, the CORE GUI will deploy the node on its assigned emulation server.</p> <p>Another way to assign emulation servers is to select one or more nodes using the select tool (ctrl-click to select multiple), and right-click one of the nodes and choose Assign to....</p> <p>The CORE emulation servers dialog box may also be used to assign nodes to servers. The assigned server name appears in parenthesis next to the node name. To assign all nodes to one of the servers, click on the server name and then the all nodes button. Servers that have assigned nodes are shown in blue in the server list. Another option is to first select a subset of nodes, then open the CORE emulation servers box and use the selected nodes button.</p> <p>IMPORTANT: Leave the nodes unassigned if they are to be run on the master server. Do not explicitly assign the nodes to the master server.</p>"},{"location":"distributed.html#gui-visualization","title":"GUI Visualization","text":"<p>If there is a link between two nodes residing on different servers, the GUI will draw the link with a dashed line.</p>"},{"location":"distributed.html#concerns-and-limitations","title":"Concerns and Limitations","text":"<p>Wireless nodes, i.e. those connected to a WLAN node, can be assigned to different emulation servers and participate in the same wireless network only if an EMANE model is used for the WLAN. The basic range model does not work across multiple servers due to the Linux bridging and nftables rules that are used.</p> <p>Note</p> <p>The basic range wireless model does not support distributed emulation, but EMANE does.</p> <p>When nodes are linked across servers core-daemons will automatically create necessary tunnels between the nodes when executed. Care should be taken to arrange the topology such that the number of tunnels is minimized. The tunnels carry data between servers to connect nodes as specified in the topology. These tunnels are created using GRE tunneling, similar to the Tunnel Tool.</p>"},{"location":"distributed.html#distributed-checklist","title":"Distributed Checklist","text":"<ol> <li>Install CORE on master server</li> <li>Install distributed CORE package on all servers needed</li> <li>Installed and configure public-key SSH access on all servers (if you want to use    double-click shells or Widgets.) for both the GUI user (for terminals) and root for running CORE commands</li> <li>Update CORE configuration as needed</li> <li>Choose the servers that participate in distributed emulation.</li> <li>Assign nodes to desired servers, empty for master server.</li> <li>Press the Start button to launch the distributed emulation.</li> </ol>"},{"location":"docker.html","title":"Docker Node Support","text":""},{"location":"docker.html#overview","title":"Overview","text":"<p>Provided below is some information for helping setup and use Docker nodes within a CORE scenario.</p>"},{"location":"docker.html#installation","title":"Installation","text":""},{"location":"docker.html#debian-systems","title":"Debian Systems","text":"<pre><code>sudo apt install docker.io\n</code></pre>"},{"location":"docker.html#rhel-systems","title":"RHEL Systems","text":""},{"location":"docker.html#configuration","title":"Configuration","text":"<p>Custom configuration required to avoid iptable rules being added and removing the need for the default docker network, since core will be orchestrating connections between nodes.</p> <p>Place the file below in /etc/docker/daemon.json</p> <pre><code>{\n  \"bridge\": \"none\",\n  \"iptables\": false\n}\n</code></pre>"},{"location":"docker.html#group-setup","title":"Group Setup","text":"<p>To use Docker nodes within the python GUI, you will need to make sure the user running the GUI is a member of the docker group.</p> <pre><code># add group if does not exist\nsudo groupadd docker\n\n# add user to group\nsudo usermod -aG docker $USER\n\n# to get this change to take effect, log out and back in or run the following\nnewgrp docker\n</code></pre>"},{"location":"docker.html#image-requirements","title":"Image Requirements","text":"<p>Images used by Docker nodes in CORE need to have networking tools installed for CORE to automate setup and configuration of the network within the container.</p> <p>Example Dockerfile:</p> <pre><code>FROM ubuntu:latest\nRUN apt-get update\nRUN apt-get install -y iproute2 ethtool\n</code></pre> <p>Build image:</p> <pre><code>sudo docker build -t &lt;name&gt; .\n</code></pre>"},{"location":"docker.html#tools-and-versions-tested-with","title":"Tools and Versions Tested With","text":"<ul> <li>Docker version 18.09.5, build e8ff056</li> <li>nsenter from util-linux 2.31.1</li> </ul>"},{"location":"emane.html","title":"EMANE (Extendable Mobile Ad-hoc Network Emulator)","text":""},{"location":"emane.html#what-is-emane","title":"What is EMANE?","text":"<p>The Extendable Mobile Ad-hoc Network Emulator (EMANE) allows heterogeneous network emulation using a pluggable MAC and PHY layer architecture. The EMANE framework provides an implementation architecture for modeling different radio interface types in the form of Network Emulation Modules (NEMs) and incorporating these modules into a real-time emulation running in a distributed environment.</p> <p>EMANE is developed by U.S. Naval Research Labs (NRL) Code 5522 and Adjacent Link LLC, who maintain these websites:</p> <ul> <li>https://github.com/adjacentlink/emane</li> <li>http://www.adjacentlink.com/</li> </ul> <p>Instead of building Linux Ethernet bridging networks with CORE, higher-fidelity wireless networks can be emulated using EMANE bound to virtual devices. CORE emulates layers 3 and above (network, session, application) with its virtual network stacks and process space for protocols and applications, while EMANE emulates layers 1 and 2 (physical and data link) using its pluggable PHY and MAC models.</p> <p>The interface between CORE and EMANE is a TAP device. CORE builds the virtual node using Linux network namespaces, installs the TAP device into the namespace and instantiates one EMANE process in the namespace. The EMANE process binds a user space socket to the TAP device for sending and receiving data from CORE.</p> <p>An EMANE instance sends and receives OTA (Over-The-Air) traffic to and from other EMANE instances via a control port (e.g. ctrl0, ctrl1). It also sends and receives Events to and from the Event Service using the same or a different control port. EMANE models are configured through the GUI's configuration dialog. A corresponding EmaneModel Python class is sub-classed for each supported EMANE model, to provide configuration items and their mapping to XML files. This way new models can be easily supported. When CORE starts the emulation, it generates the appropriate XML files that specify the EMANE NEM configuration, and launches the EMANE daemons.</p> <p>Some EMANE models support location information to determine when packets should be dropped. EMANE has an event system where location events are broadcast to all NEMs. CORE can generate these location events when nodes are moved on the canvas. The canvas size and scale dialog has controls for mapping the X,Y coordinate system to a latitude, longitude geographic system that EMANE uses. When specified in the core.conf configuration file, CORE can also subscribe to EMANE location events and move the nodes on the canvas as they are moved in the EMANE emulation. This would occur when an Emulation Script Generator, for example, is running a mobility script.</p>"},{"location":"emane.html#emane-in-core","title":"EMANE in CORE","text":"<p>This section will cover some high level topics and examples for running and using EMANE in CORE.</p> <p>You can find more detailed tutorials and examples at the EMANE Tutorial.</p> <p>Every topic below assumes CORE, EMANE, and OSPF MDR have been installed.</p> <p>Info</p> <p>Demo files will be found within the <code>core-gui</code> ~/.coregui/xmls directory</p> Topic Model Description XML Files RF Pipe Overview of generated XML files used to drive EMANE GPSD RF Pipe Overview of running and integrating gpsd with EMANE Precomputed RF Pipe Overview of using the precomputed propagation model EEL RF Pipe Overview of using the Emulation Event Log (EEL) Generator Antenna Profiles RF Pipe Overview of using antenna profiles in EMANE"},{"location":"emane.html#emane-configuration","title":"EMANE Configuration","text":"<p>The CORE configuration file /opt/core/etc/core.conf has options specific to EMANE. An example emane section from the core.conf file is shown below:</p> <pre><code># EMANE configuration\nemane_platform_port = 8101\nemane_transform_port = 8201\nemane_event_monitor = False\n#emane_models_dir = /home/&lt;user&gt;/.coregui/custom_emane\n# EMANE log level range [0,4] default: 2\nemane_log_level = 2\nemane_realtime = True\n# prefix used for emane installation\n# emane_prefix = /usr\n</code></pre> <p>If you have an EMANE event generator (e.g. mobility or pathloss scripts) and want to have CORE subscribe to EMANE location events, set the following line in the core.conf configuration file.</p> <p>Note</p> <p>Do not set this option to True if you want to manually drag nodes around on the canvas to update their location in EMANE.</p> <pre><code>emane_event_monitor = True\n</code></pre> <p>Another common issue is if installing EMANE from source, the default configure prefix will place the DTD files in /usr/local/share/emane/dtd while CORE expects them in /usr/share/emane/dtd.</p> <p>Update the EMANE prefix configuration to resolve this problem.</p> <pre><code>emane_prefix = /usr/local\n</code></pre>"},{"location":"emane.html#custom-emane-models","title":"Custom EMANE Models","text":"<p>CORE supports custom developed EMANE models by way of dynamically loading user created python files that represent the model. Custom EMANE models should be placed within the path defined by emane_models_dir in the CORE configuration file. This path cannot end in /emane.</p> <p>Here is an example model with documentation describing functionality:</p> <pre><code>\"\"\"\nExample custom emane model.\n\"\"\"\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom core.config import Configuration\nfrom core.emane import emanemanifest, emanemodel\n\n\nclass ExampleModel(emanemodel.EmaneModel):\n    \"\"\"\n    Custom emane model.\n\n    :cvar name: defines the emane model name that will show up in the GUI\n\n    Mac Definition:\n    :cvar mac_library: defines that mac library that the model will reference\n    :cvar mac_xml: defines the mac manifest file that will be parsed to obtain configuration options,\n        that will be displayed within the GUI\n    :cvar mac_defaults: allows you to override options that are maintained within the manifest file above\n    :cvar mac_config: parses the manifest file and converts configurations into core supported formats\n\n    Phy Definition:\n    NOTE: phy configuration will default to the universal model as seen below and the below section does not\n    have to be included\n    :cvar phy_library: defines that phy library that the model will reference, used if you need to\n        provide a custom phy\n    :cvar phy_xml: defines the phy manifest file that will be parsed to obtain configuration options,\n        that will be displayed within the GUI\n    :cvar phy_defaults: allows you to override options that are maintained within the manifest file above\n        or for the default universal model\n    :cvar phy_config: parses the manifest file and converts configurations into core supported formats\n\n    Custom Override Options:\n    NOTE: these options default to what's seen below and do not have to be included\n    :cvar config_ignore: allows you to ignore options within phy/mac, used typically if you needed to add\n        a custom option for display within the gui\n    \"\"\"\n\n    name: str = \"emane_example\"\n    mac_library: str = \"rfpipemaclayer\"\n    mac_xml: str = \"rfpipemaclayer.xml\"\n    mac_defaults: dict[str, str] = {\n        \"pcrcurveuri\": \"/usr/share/emane/xml/models/mac/rfpipe/rfpipepcr.xml\"\n    }\n    mac_config: list[Configuration] = []\n    phy_library: Optional[str] = None\n    phy_xml: str = \"emanephy.xml\"\n    phy_defaults: dict[str, str] = {\n        \"subid\": \"1\",\n        \"propagationmodel\": \"2ray\",\n        \"noisemode\": \"none\",\n    }\n    phy_config: list[Configuration] = []\n    config_ignore: set[str] = set()\n\n    @classmethod\n    def load(cls, emane_prefix: Path) -&gt; None:\n        \"\"\"\n        Called after being loaded within the EmaneManager. Provides configured\n        emane_prefix for parsing xml files.\n\n        :param emane_prefix: configured emane prefix path\n        :return: nothing\n        \"\"\"\n        cls._load_platform_config(emane_prefix)\n        manifest_path = \"share/emane/manifest\"\n        # load mac configuration\n        mac_xml_path = emane_prefix / manifest_path / cls.mac_xml\n        cls.mac_config = emanemanifest.parse(mac_xml_path, cls.mac_defaults)\n        # load phy configuration\n        phy_xml_path = emane_prefix / manifest_path / cls.phy_xml\n        cls.phy_config = emanemanifest.parse(phy_xml_path, cls.phy_defaults)\n</code></pre>"},{"location":"emane.html#single-pc-with-emane","title":"Single PC with EMANE","text":"<p>This section describes running CORE and EMANE on a single machine. This is the default mode of operation when building an EMANE network with CORE. The OTA manager and Event service interface are set to use ctrl0 and the virtual nodes use the primary control channel for communicating with one another. The primary control channel is automatically activated when a scenario involves EMANE. Using the primary control channel prevents your emulation session from sending multicast traffic on your local network and interfering with other EMANE users.</p> <p>EMANE is configured through an EMANE node. Once a node is linked to an EMANE cloud, the radio interface on that node may also be configured separately (apart from the cloud.)</p> <p>Right click on an EMANE node and select EMANE Config to open the configuration dialog. The EMANE models should be listed here for selection. (You may need to restart the CORE daemon if it was running prior to installing the EMANE Python bindings.)</p> <p>When an EMANE model is selected, you can click on the models option button causing the GUI to query the CORE daemon for configuration items. Each model will have different parameters, refer to the EMANE documentation for an explanation of each item. The defaults values are presented in the dialog. Clicking Apply and Apply again will store the EMANE model selections.</p> <p>The RF-PIPE and IEEE 802.11abg models use a Universal PHY that supports geographic location information for determining pathloss between nodes. A default latitude and longitude location is provided by CORE and this location-based pathloss is enabled by default; this is the pathloss mode setting for the Universal PHY. Moving a node on the canvas while the emulation is running generates location events for EMANE. To view or change the geographic location or scale of the canvas use the Canvas Size and Scale dialog available from the Canvas menu.</p> <p>Note that conversion between geographic and Cartesian coordinate systems is done using UTM (Universal Transverse Mercator) projection, where different zones of 6 degree longitude bands are defined. The location events generated by CORE may become inaccurate near the zone boundaries for very large scenarios that span multiple UTM zones. It is recommended that EMANE location scripts be used to achieve geo-location accuracy in this situation.</p> <p>Clicking the green Start button launches the emulation and causes TAP devices to be created in the virtual nodes that are linked to the EMANE WLAN. These devices appear with interface names such as eth0, eth1, etc. The EMANE processes should now be running in each namespace.</p> <p>To view the configuration generated by CORE, look in the /tmp/pycore.nnnnn/ session directory to find the generated EMANE xml files. One easy way to view this information is by double-clicking one of the virtual nodes and listing the files in the shell.</p> <p></p>"},{"location":"emane.html#distributed-emane","title":"Distributed EMANE","text":"<p>Running CORE and EMANE distributed among two or more emulation servers is similar to running on a single machine. There are a few key configuration items that need to be set in order to be successful, and those are outlined here.</p> <p>It is a good idea to maintain separate networks for data (OTA) and control. The control network may be a shared laboratory network, for example, and you do not want multicast traffic on the data network to interfere with other EMANE users. Furthermore, control traffic could interfere with the OTA latency and throughput and might affect emulation fidelity. The examples described here will use eth0 as a control interface and eth1 as a data interface, although using separate interfaces is not strictly required. Note that these interface names refer to interfaces present on the host machine, not virtual interfaces within a node.</p> <p>IMPORTANT: If an auxiliary control network is used, an interface on the host has to be assigned to that network.</p> <p>Each machine that will act as an emulation server needs to have CORE distributed and EMANE installed. As well as be setup to work for CORE distributed mode.</p> <p>The IP addresses of the available servers are configured from the CORE servers dialog box. The dialog shows available servers, some or all of which may be assigned to nodes on the canvas.</p> <p>Nodes need to be assigned to servers and can be done so using the node configuration dialog. When a node is not assigned to any emulation server, it will be emulated locally.</p> <p>Using the EMANE node configuration dialog. You can change the EMANE model being used, along with changing any configuration setting from their defaults.</p> <p></p> <p>Note</p> <p>Here is a quick checklist for distributed emulation with EMANE.</p> <ol> <li>Follow the steps outlined for normal CORE.</li> <li>Assign nodes to desired servers</li> <li>Synchronize your machine's clocks prior to starting the emulation,    using ntp or ptp. Some EMANE models are sensitive to timing.</li> <li>Press the Start button to launch the distributed emulation.</li> </ol> <p>Now when the Start button is used to instantiate the emulation, the local CORE daemon will connect to other emulation servers that have been assigned to nodes. Each server will have its own session directory where the platform.xml file and other EMANE XML files are generated. The NEM IDs are automatically coordinated across servers so there is no overlap.</p> <p>An Ethernet device is used for disseminating multicast EMANE events, as specified in the configure emane dialog. EMANE's Event Service can be run with mobility or pathloss scripts. If CORE is not subscribed to location events, it will generate them as nodes are moved on the canvas.</p> <p>Double-clicking on a node during runtime will cause the GUI to attempt to SSH to the emulation server for that node and run an interactive shell. The public key SSH configuration should be tested with all emulation servers prior to starting the emulation.</p>"},{"location":"grpc.html","title":"gRPC API","text":""},{"location":"grpc.html#overview","title":"Overview","text":"<p>gRPC is a client/server API for interfacing with CORE and used by the python GUI for driving all functionality. It is dependent on having a running <code>core-daemon</code> instance to be leveraged.</p> <p>A python client can be created from the raw generated grpc files included with CORE or one can leverage a provided gRPC client that helps encapsulate some functionality to try and help make things easier.</p>"},{"location":"grpc.html#python-client","title":"Python Client","text":"<p>A python client wrapper is provided at CoreGrpcClient to help provide some conveniences when using the API.</p>"},{"location":"grpc.html#client-http-proxy","title":"Client HTTP Proxy","text":"<p>Since gRPC is HTTP2 based, proxy configurations can cause issues. By default, the client disables proxy support to avoid issues when a proxy is present. You can enable and properly account for this issue when needed.</p>"},{"location":"grpc.html#proto-files","title":"Proto Files","text":"<p>Proto files are used to define the API and protobuf messages that are used for interfaces with this API.</p> <p>They can be found here to see the specifics of what is going on and response message values that would be returned.</p>"},{"location":"grpc.html#examples","title":"Examples","text":""},{"location":"grpc.html#node-models","title":"Node Models","text":"<p>When creating nodes of type <code>NodeType.DEFAULT</code> these are the default models and the services they map to.</p> <ul> <li>mdr<ul> <li>zebra, OSPFv3MDR, IPForward</li> </ul> </li> <li>PC<ul> <li>DefaultRoute</li> </ul> </li> <li>router<ul> <li>zebra, OSPFv2, OSPFv3, IPForward</li> </ul> </li> <li>host<ul> <li>DefaultRoute, SSH</li> </ul> </li> </ul>"},{"location":"grpc.html#interface-helper","title":"Interface Helper","text":"<p>There is an interface helper class that can be leveraged for convenience when creating interface data for nodes. Alternatively one can manually create a <code>core.api.grpc.wrappers.Interface</code> class instead with appropriate information.</p> <p>Manually creating gRPC client interface:</p> <pre><code>from core.api.grpc.wrappers import Interface\n\n# id is optional and will set to the next available id\n# name is optional and will default to eth&lt;id&gt;\n# mac is optional and will result in a randomly generated mac\niface = Interface(\n    id=0,\n    name=\"eth0\",\n    ip4=\"10.0.0.1\",\n    ip4_mask=24,\n    ip6=\"2001::\",\n    ip6_mask=64,\n)\n</code></pre> <p>Leveraging the interface helper class:</p> <pre><code>from core.api.grpc import client\n\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n# node_id is used to get an ip4/ip6 address indexed from within the above prefixes\n# iface_id is required and used exactly for that\n# name is optional and would default to eth&lt;id&gt;\n# mac is optional and will result in a randomly generated mac\niface_data = iface_helper.create_iface(\n    node_id=1, iface_id=0, name=\"eth0\", mac=\"00:00:00:00:aa:00\"\n)\n</code></pre>"},{"location":"grpc.html#listening-to-events","title":"Listening to Events","text":"<p>Various events that can occur within a session can be listened to.</p> <p>Event types:</p> <ul> <li>session - events for changes in session state and mobility start/stop/pause</li> <li>node - events for node movements and icon changes</li> <li>link - events for link configuration changes and wireless link add/delete</li> <li>config - configuration events when legacy gui joins a session</li> <li>alert - alert events</li> <li>file - file events when the legacy gui joins a session</li> </ul> <pre><code>from core.api.grpc import client\nfrom core.api.grpc.wrappers import EventType\n\n\ndef event_listener(event):\n    print(event)\n\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# provide no events to listen to all events\ncore.events(session.id, event_listener)\n\n# provide events to listen to specific events\ncore.events(session.id, event_listener, [EventType.NODE])\n</code></pre>"},{"location":"grpc.html#configuring-links","title":"Configuring Links","text":"<p>Links can be configured at the time of creation or during runtime.</p> <p>Currently supported configuration options:</p> <ul> <li>bandwidth (bps)</li> <li>delay (us)</li> <li>duplicate (%)</li> <li>jitter (us)</li> <li>loss (%)</li> </ul> <pre><code>from core.api.grpc import client\nfrom core.api.grpc.wrappers import LinkOptions, Position\n\n# interface helper\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# create nodes\nposition = Position(x=100, y=100)\nnode1 = session.add_node(1, position=position)\nposition = Position(x=300, y=100)\nnode2 = session.add_node(2, position=position)\n\n# configuring when creating a link\noptions = LinkOptions(\n    bandwidth=54_000_000,\n    delay=5000,\n    dup=5,\n    loss=5.5,\n    jitter=0,\n)\niface1 = iface_helper.create_iface(node1.id, 0)\niface2 = iface_helper.create_iface(node2.id, 0)\nlink = session.add_link(node1=node1, node2=node2, iface1=iface1, iface2=iface2)\n\n# start session\ncore.start_session(session)\n\n# configuring during runtime\nlink.options.loss = 10.0\ncore.edit_link(session.id, link)\n</code></pre>"},{"location":"grpc.html#peer-to-peer-example","title":"Peer to Peer Example","text":"<pre><code># required imports\nfrom core.api.grpc import client\nfrom core.api.grpc.wrappers import Position\n\n# interface helper\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# create nodes\nposition = Position(x=100, y=100)\nnode1 = session.add_node(1, position=position)\nposition = Position(x=300, y=100)\nnode2 = session.add_node(2, position=position)\n\n# create link\niface1 = iface_helper.create_iface(node1.id, 0)\niface2 = iface_helper.create_iface(node2.id, 0)\nsession.add_link(node1=node1, node2=node2, iface1=iface1, iface2=iface2)\n\n# start session\ncore.start_session(session)\n</code></pre>"},{"location":"grpc.html#switchhub-example","title":"Switch/Hub Example","text":"<pre><code># required imports\nfrom core.api.grpc import client\nfrom core.api.grpc.wrappers import NodeType, Position\n\n# interface helper\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# create nodes\nposition = Position(x=200, y=200)\nswitch = session.add_node(1, _type=NodeType.SWITCH, position=position)\nposition = Position(x=100, y=100)\nnode1 = session.add_node(2, position=position)\nposition = Position(x=300, y=100)\nnode2 = session.add_node(3, position=position)\n\n# create links\niface1 = iface_helper.create_iface(node1.id, 0)\nsession.add_link(node1=node1, node2=switch, iface1=iface1)\niface1 = iface_helper.create_iface(node2.id, 0)\nsession.add_link(node1=node2, node2=switch, iface1=iface1)\n\n# start session\ncore.start_session(session)\n</code></pre>"},{"location":"grpc.html#wlan-example","title":"WLAN Example","text":"<pre><code># required imports\nfrom core.api.grpc import client\nfrom core.api.grpc.wrappers import NodeType, Position\n\n# interface helper\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# create nodes\nposition = Position(x=200, y=200)\nwlan = session.add_node(1, _type=NodeType.WIRELESS_LAN, position=position)\nposition = Position(x=100, y=100)\nnode1 = session.add_node(2, model=\"mdr\", position=position)\nposition = Position(x=300, y=100)\nnode2 = session.add_node(3, model=\"mdr\", position=position)\n\n# create links\niface1 = iface_helper.create_iface(node1.id, 0)\nsession.add_link(node1=node1, node2=wlan, iface1=iface1)\niface1 = iface_helper.create_iface(node2.id, 0)\nsession.add_link(node1=node2, node2=wlan, iface1=iface1)\n\n# set wlan config using a dict mapping currently\n# support values as strings\nwlan.set_wlan(\n    {\n        \"range\": \"280\",\n        \"bandwidth\": \"55000000\",\n        \"delay\": \"6000\",\n        \"jitter\": \"5\",\n        \"error\": \"5\",\n    }\n)\n\n# start session\ncore.start_session(session)\n</code></pre>"},{"location":"grpc.html#emane-example","title":"EMANE Example","text":"<p>For EMANE you can import and use one of the existing models and use its name for configuration.</p> <p>Current models:</p> <ul> <li>core.emane.ieee80211abg.EmaneIeee80211abgModel</li> <li>core.emane.rfpipe.EmaneRfPipeModel</li> <li>core.emane.tdma.EmaneTdmaModel</li> <li>core.emane.bypass.EmaneBypassModel</li> </ul> <p>Their configurations options are driven dynamically from parsed EMANE manifest files from the installed version of EMANE.</p> <p>Options and their purpose can be found at the EMANE Wiki.</p> <p>If configuring EMANE global settings or model mac/phy specific settings, any value not provided will use the defaults. When no configuration is used, the defaults are used.</p> <pre><code># required imports\nfrom core.api.grpc import client\nfrom core.api.grpc.wrappers import NodeType, Position\nfrom core.emane.models.ieee80211abg import EmaneIeee80211abgModel\n\n# interface helper\niface_helper = client.InterfaceHelper(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n\n# create grpc client and connect\ncore = client.CoreGrpcClient()\ncore.connect()\n\n# add session\nsession = core.create_session()\n\n# create nodes\nposition = Position(x=200, y=200)\nemane = session.add_node(\n    1, _type=NodeType.EMANE, position=position, emane=EmaneIeee80211abgModel.name\n)\nposition = Position(x=100, y=100)\nnode1 = session.add_node(2, model=\"mdr\", position=position)\nposition = Position(x=300, y=100)\nnode2 = session.add_node(3, model=\"mdr\", position=position)\n\n# create links\niface1 = iface_helper.create_iface(node1.id, 0)\nsession.add_link(node1=node1, node2=emane, iface1=iface1)\niface1 = iface_helper.create_iface(node2.id, 0)\nsession.add_link(node1=node2, node2=emane, iface1=iface1)\n\n# setting emane specific emane model configuration\nemane.set_emane_model(EmaneIeee80211abgModel.name, {\n    \"eventservicettl\": \"2\",\n    \"unicastrate\": \"3\",\n})\n\n# start session\ncore.start_session(session)\n</code></pre> <p>EMANE Model Configuration:</p> <pre><code># emane network specific config, set on an emane node\n# this setting applies to all nodes connected\nemane.set_emane_model(EmaneIeee80211abgModel.name, {\"unicastrate\": \"3\"})\n\n# node specific config for an individual node connected to an emane network\nnode.set_emane_model(EmaneIeee80211abgModel.name, {\"unicastrate\": \"3\"})\n\n# node interface specific config for an individual node connected to an emane network\nnode.set_emane_model(EmaneIeee80211abgModel.name, {\"unicastrate\": \"3\"}, iface_id=0)\n</code></pre>"},{"location":"grpc.html#configuring-a-service","title":"Configuring a Service","text":"<p>Services help generate and run bash scripts on nodes for a given purpose.</p> <p>Configuring the files of a service results in a specific hard coded script being generated, instead of the default scripts, that may leverage dynamic generation.</p> <p>The following features can be configured for a service:</p> <ul> <li>files - files that will be generated</li> <li>directories - directories that will be mounted unique to the node</li> <li>startup - commands to run start a service</li> <li>validate - commands to run to validate a service</li> <li>shutdown - commands to run to stop a service</li> </ul> <p>Editing service properties:</p> <pre><code># configure a service, for a node, for a given session\nnode.service_configs[service_name] = NodeServiceData(\n    configs=[\"file1.sh\", \"file2.sh\"],\n    directories=[\"/etc/node\"],\n    startup=[\"bash file1.sh\"],\n    validate=[],\n    shutdown=[],\n)\n</code></pre> <p>When editing a service file, it must be the name of <code>config</code> file that the service will generate.</p> <p>Editing a service file:</p> <pre><code># to edit the contents of a generated file you can specify\n# the service, the file name, and its contents\nfile_configs = node.service_file_configs.setdefault(service_name, {})\nfile_configs[file_name] = \"echo hello world\"\n</code></pre>"},{"location":"grpc.html#file-examples","title":"File Examples","text":"<p>File versions of the network examples can be found here. These examples will create a session using the gRPC API when the core-daemon is running.</p> <p>You can then switch to and attach to these sessions using either of the CORE GUIs.</p>"},{"location":"gui.html","title":"CORE GUI","text":""},{"location":"gui.html#overview","title":"Overview","text":"<p>The GUI is used to draw nodes and network devices on a canvas, linking them together to create an emulated network session.</p> <p>After pressing the start button, CORE will proceed through these phases, staying in the runtime phase. After the session is stopped, CORE will proceed to the data collection phase before tearing down the emulated state.</p> <p>CORE can be customized to perform any action at each state. See the Hooks... entry on the Session Menu for details about when these session states are reached.</p>"},{"location":"gui.html#prerequisites","title":"Prerequisites","text":"<p>Beyond installing CORE, you must have the CORE daemon running. This is done on the command line with either systemd or sysv.</p> <pre><code># systemd service\nsudo systemctl daemon-reload\nsudo systemctl start core-daemon\n\n# direct invocation\nsudo core-daemon\n</code></pre>"},{"location":"gui.html#gui-files","title":"GUI Files","text":"<p>The GUI will create a directory in your home directory on first run called ~/.coregui. This directory will help layout various files that the GUI may use.</p> <ul> <li>.coregui/<ul> <li>backgrounds/<ul> <li>place backgrounds used for display in the GUI</li> </ul> </li> <li>custom_emane/<ul> <li>place to keep custom emane models to use with the core-daemon</li> </ul> </li> <li>custom_services/<ul> <li>place to keep custom services to use with the core-daemon</li> </ul> </li> <li>icons/<ul> <li>icons the GUI uses along with customs icons desired</li> </ul> </li> <li>mobility/<ul> <li>place to keep custom mobility files</li> </ul> </li> <li>scripts/<ul> <li>place to keep core related scripts</li> </ul> </li> <li>xmls/<ul> <li>place to keep saved session xml files</li> </ul> </li> <li>gui.log<ul> <li>log file when running the gui, look here when issues occur for exceptions etc</li> </ul> </li> <li>config.yaml<ul> <li>configuration file used to save/load various gui related settings (custom nodes, layouts, addresses, etc)</li> </ul> </li> </ul> </li> </ul>"},{"location":"gui.html#modes-of-operation","title":"Modes of Operation","text":"<p>The CORE GUI has two primary modes of operation, Edit and Execute modes. Running the GUI, by typing core-gui with no options, starts in Edit mode. Nodes are drawn on a blank canvas using the toolbar on the left and configured from right-click menus or by double-clicking them. The GUI does not need to be run as root.</p> <p>Once editing is complete, pressing the green Start button instantiates the topology and enters Execute mode. In execute mode, the user can interact with the running emulated machines by double-clicking or right-clicking on them. The editing toolbar disappears and is replaced by an execute toolbar, which provides tools while running the emulation. Pressing the red Stop button will destroy the running emulation and return CORE to Edit mode.</p> <p>Once the emulation is running, the GUI can be closed, and a prompt will appear asking if the emulation should be terminated. The emulation may be left running and the GUI can reconnect to an existing session at a later time.</p> <p>The GUI can be run as a normal user on Linux.</p> <p>The GUI currently provides the following options on startup.</p> <pre><code>usage: core-gui [-h] [-l {DEBUG,INFO,WARNING,ERROR,CRITICAL}] [-p]\n                [-s SESSION] [--create-dir]\n\nCORE Python GUI\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -l {DEBUG,INFO,WARNING,ERROR,CRITICAL}, --level {DEBUG,INFO,WARNING,ERROR,CRITICAL}\n                        logging level\n  -p, --proxy           enable proxy\n  -s SESSION, --session SESSION\n                        session id to join\n  --create-dir          create gui directory and exit\n</code></pre>"},{"location":"gui.html#toolbar","title":"Toolbar","text":"<p>The toolbar is a row of buttons that runs vertically along the left side of the CORE GUI window. The toolbar changes depending on the mode of operation.</p>"},{"location":"gui.html#editing-toolbar","title":"Editing Toolbar","text":"<p>When CORE is in Edit mode (the default), the vertical Editing Toolbar exists on the left side of the CORE window. Below are brief descriptions for each toolbar item, starting from the top. Most of the tools are grouped into related sub-menus, which appear when you click on their group icon.</p> Icon Name Description Selection Tool Tool for selecting, moving, configuring nodes. Start Button Starts Execute mode, instantiates the emulation. Link Allows network links to be drawn between two nodes by clicking and dragging the mouse."},{"location":"gui.html#core-nodes","title":"CORE Nodes","text":"<p>These nodes will create a new node container and run associated services.</p> Icon Name Description Router Runs Quagga OSPFv2 and OSPFv3 routing to forward packets. Host Emulated server machine having a default route, runs SSH server. PC Basic emulated machine having a default route, runs no processes by default. MDR Runs Quagga OSPFv3 MDR routing for MANET-optimized routing. PRouter Physical router represents a real testbed machine."},{"location":"gui.html#network-nodes","title":"Network Nodes","text":"<p>These nodes are mostly used to create a Linux bridge that serves the purpose described below.</p> Icon Name Description Hub Ethernet hub forwards incoming packets to every connected node. Switch Ethernet switch intelligently forwards incoming packets to attached hosts using an Ethernet address hash table. Wireless LAN When routers are connected to this WLAN node, they join a wireless network and an antenna is drawn instead of a connecting line; the WLAN node typically controls connectivity between attached wireless nodes based on the distance between them. RJ45 RJ45 Physical Interface Tool, emulated nodes can be linked to real physical interfaces; using this tool, real networks and devices can be physically connected to the live-running emulation. Tunnel Tool allows connecting together more than one CORE emulation using GRE tunnels."},{"location":"gui.html#annotation-tools","title":"Annotation Tools","text":"Icon Name Description Marker For drawing marks on the canvas. Oval For drawing circles on the canvas that appear in the background. Rectangle For drawing rectangles on the canvas that appear in the background. Text For placing text captions on the canvas."},{"location":"gui.html#execution-toolbar","title":"Execution Toolbar","text":"<p>When the Start button is pressed, CORE switches to Execute mode, and the Edit toolbar on the left of the CORE window is replaced with the Execution toolbar Below are the items on this toolbar, starting from the top.</p> Icon Name Description Stop Button Stops Execute mode, terminates the emulation, returns CORE to edit mode. Selection Tool In Execute mode, the Selection Tool can be used for moving nodes around the canvas, and double-clicking on a node will open a shell window for that node; right-clicking on a node invokes a pop-up menu of run-time options for that node. Marker For drawing freehand lines on the canvas, useful during demonstrations; markings are not saved. Run Tool This tool allows easily running a command on all or a subset of all nodes. A list box allows selecting any of the nodes. A text entry box allows entering any command. The command should return immediately, otherwise the display will block awaiting response. The ping command, for example, with no parameters, is not a good idea. The result of each command is displayed in a results box. The first occurrence of the special text \"NODE\" will be replaced with the node name. The command will not be attempted to run on nodes that are not routers, PCs, or hosts, even if they are selected."},{"location":"gui.html#menu","title":"Menu","text":"<p>The menubar runs along the top of the CORE GUI window and provides access to a variety of features. Some of the menus are detachable, such as the Widgets menu, by clicking the dashed line at the top.</p>"},{"location":"gui.html#file-menu","title":"File Menu","text":"<p>The File menu contains options for saving and opening saved sessions.</p> Option Description New Session This starts a new session with an empty canvas. Save Saves the current topology. If you have not yet specified a file name, the Save As dialog box is invoked. Save As Invokes the Save As dialog box for selecting a new .xml file for saving the current configuration in the XML file. Open Invokes the File Open dialog box for selecting a new XML file to open. Recently used files Above the Quit menu command is a list of recently use files, if any have been opened. You can clear this list in the Preferences dialog box. You can specify the number of files to keep in this list from the Preferences dialog. Click on one of the file names listed to open that configuration file. Execute Python Script Invokes a File Open dialog box for selecting a Python script to run and automatically connect to. After a selection is made, a Python Script Options dialog box is invoked to allow for command-line options to be added. The Python script must create a new CORE Session and add this session to the daemon's list of sessions in order for this to work. Quit The Quit command should be used to exit the CORE GUI. CORE may prompt for termination if you are currently in Execute mode. Preferences and the recently-used files list are saved."},{"location":"gui.html#edit-menu","title":"Edit Menu","text":"Option Description Preferences Invokes the Preferences dialog box. Custom Nodes Custom node creation dialog box. Undo (Disabled) Attempts to undo the last edit in edit mode. Redo (Disabled) Attempts to redo an edit that has been undone. Cut, Copy, Paste, Delete Used to cut, copy, paste, and delete a selection. When nodes are pasted, their node numbers are automatically incremented, and existing links are preserved with new IP addresses assigned. Services and their customizations are copied to the new node, but care should be taken as node IP addresses have changed with possibly old addresses remaining in any custom service configurations. Annotations may also be copied and pasted."},{"location":"gui.html#canvas-menu","title":"Canvas Menu","text":"<p>The canvas menu provides commands related to the editing canvas.</p> Option Description Size/scale Invokes a Canvas Size and Scale dialog that allows configuring the canvas size, scale, and geographic reference point. The size controls allow changing the width and height of the current canvas, in pixels or meters. The scale allows specifying how many meters are equivalent to 100 pixels. The reference point controls specify the latitude, longitude, and altitude reference point used to convert between geographic and Cartesian coordinate systems. By clicking the Save as default option, all new canvases will be created with these properties. The default canvas size can also be changed in the Preferences dialog box. Wallpaper Used for setting the canvas background image."},{"location":"gui.html#view-menu","title":"View Menu","text":"<p>The View menu features items for toggling on and off their display on the canvas.</p> Option Description Interface Names Display interface names on links. IPv4 Addresses Display IPv4 addresses on links. IPv6 Addresses Display IPv6 addresses on links. Node Labels Display node names. Link Labels Display link labels. Annotations Display annotations. Canvas Grid Display the canvas grid."},{"location":"gui.html#tools-menu","title":"Tools Menu","text":"<p>The tools menu lists different utility functions.</p> Option Description Find Display find dialog used for highlighting a node on the canvas. Auto Grid Automatically layout nodes in a grid. IP addresses Invokes the IP Addresses dialog box for configuring which IPv4/IPv6 prefixes are used when automatically addressing new interfaces. MAC addresses Invokes the MAC Addresses dialog box for configuring the starting number used as the lowest byte when generating each interface MAC address. This value should be changed when tunneling between CORE emulations to prevent MAC address conflicts."},{"location":"gui.html#widgets-menu","title":"Widgets Menu","text":"<p>Widgets are GUI elements that allow interaction with a running emulation. Widgets typically automate the running of commands on emulated nodes to report status information of some type and display this on screen.</p>"},{"location":"gui.html#periodic-widgets","title":"Periodic Widgets","text":"<p>These Widgets are those available from the main Widgets menu. More than one of these Widgets may be run concurrently. An event loop fires once every second that the emulation is running. If one of these Widgets is enabled, its periodic routine will be invoked at this time. Each Widget may have a configuration dialog box which is also accessible from the Widgets menu.</p> <p>Here are some standard widgets:</p> <ul> <li>Adjacency - displays router adjacency states for Quagga's OSPFv2 and OSPFv3   routing protocols. A line is drawn from each router halfway to the router ID   of an adjacent router. The color of the line is based on the OSPF adjacency   state such as Two-way or Full. To learn about the different colors, see the   Configure Adjacency... menu item. The vtysh command is used to   dump OSPF neighbor information.   Only half of the line is drawn because each   router may be in a different adjacency state with respect to the other.</li> <li>Throughput - displays the kilobits-per-second throughput above each link,   using statistics gathered from each link. If the throughput exceeds a certain   threshold, the link will become highlighted. For wireless nodes which broadcast   data to all nodes in range, the throughput rate is displayed next to the node and   the node will become circled if the threshold is exceeded.</li> </ul>"},{"location":"gui.html#observer-widgets","title":"Observer Widgets","text":"<p>These Widgets are available from the Observer Widgets submenu of the Widgets menu, and from the Widgets Tool on the toolbar. Only one Observer Widget may be used at a time. Mouse over a node while the session is running to pop up an informational display about that node.</p> <p>Available Observer Widgets include IPv4 and IPv6 routing tables, socket information, list of running processes, and OSPFv2/v3 neighbor information.</p> <p>Observer Widgets may be edited by the user and rearranged. Choosing Widgets-&gt;Observer Widgets-&gt;Edit Observers from the Observer Widget menu will invoke the Observer Widgets dialog. A list of Observer Widgets is displayed along with up and down arrows for rearranging the list. Controls are available for renaming each widget, for changing the command that is run during mouse over, and for adding and deleting items from the list. Note that specified commands should return immediately to avoid delays in the GUI display. Changes are saved to a config.yaml file in the CORE configuration directory.</p>"},{"location":"gui.html#session-menu","title":"Session Menu","text":"<p>The Session Menu has entries for starting, stopping, and managing sessions, in addition to global options such as node types, comments, hooks, servers, and options.</p> Option Description Sessions Invokes the CORE Sessions dialog box containing a list of active CORE sessions in the daemon. Basic session information such as name, node count, start time, and a thumbnail are displayed. This dialog allows connecting to different sessions, shutting them down, or starting a new session. Servers Invokes the CORE emulation servers dialog for configuring. Options Presents per-session options, such as the IPv4 prefix to be used, if any, for a control network the ability to preserve the session directory; and an on/off switch for SDT3D support. Hooks Invokes the CORE Session Hooks window where scripts may be configured for a particular session state. The session states are defined in the table below. The top of the window has a list of configured hooks, and buttons on the bottom left allow adding, editing, and removing hook scripts. The new or edit button will open a hook script editing window.  A hook script is a shell script invoked on the host (not within a virtual node)."},{"location":"gui.html#session-states","title":"Session States","text":"State Description Definition Used by the GUI to tell the backend to clear any state. Configuration When the user presses the Start button, node, link, and other configuration data is sent to the backend. This state is also reached when the user customizes a service. Instantiation After configuration data has been sent, just before the nodes are created. Runtime All nodes and networks have been built and are running. (This is the same state at which the previously-named global experiment script was run.) Datacollect The user has pressed the Stop button, but before services have been stopped and nodes have been shut down. This is a good time to collect log files and other data from the nodes. Shutdown All nodes and networks have been shut down and destroyed."},{"location":"gui.html#help-menu","title":"Help Menu","text":"Option Description CORE Github (www) Link to the CORE GitHub page. CORE Documentation (www) Lnk to the CORE Documentation page. About Invokes the About dialog box for viewing version information."},{"location":"gui.html#building-sample-networks","title":"Building Sample Networks","text":""},{"location":"gui.html#wired-networks","title":"Wired Networks","text":"<p>Wired networks are created using the Link Tool to draw a link between two nodes. This automatically draws a red line representing an Ethernet link and creates new interfaces on network-layer nodes.</p> <p>Double-click on the link to invoke the link configuration dialog box. Here you can change the Bandwidth, Delay, Loss, and Duplicate rate parameters for that link. You can also modify the color and width of the link, affecting its display.</p> <p>Link-layer nodes are provided for modeling wired networks. These do not create a separate network stack when instantiated, but are implemented using Linux bridging. These are the hub, switch, and wireless LAN nodes. The hub copies each packet from the incoming link to every connected link, while the switch behaves more like an Ethernet switch and keeps track of the Ethernet address of the connected peer, forwarding unicast traffic only to the appropriate ports.</p> <p>The wireless LAN (WLAN) is covered in the next section.</p>"},{"location":"gui.html#wireless-networks","title":"Wireless Networks","text":"<p>Wireless networks allow moving nodes around to impact the connectivity between them. Connections between a pair of nodes is stronger when the nodes are closer while connection is weaker when the nodes are further away. CORE offers several levels of wireless emulation fidelity, depending on modeling needs and available hardware.</p> <ul> <li>WLAN Node<ul> <li>uses set bandwidth, delay, and loss</li> <li>links are enabled or disabled based on a set range</li> <li>uses the least CPU when moving, but nothing extra when not moving</li> </ul> </li> <li>Wireless Node<ul> <li>uses set bandwidth, delay, and initial loss</li> <li>loss dynamically changes based on distance between nodes, which can be configured with range parameters</li> <li>links are enabled or disabled based on a set range</li> <li>uses more CPU to calculate loss for every movement, but nothing extra when not moving</li> </ul> </li> <li>EMANE Node<ul> <li>uses a physical layer model to account for signal propagation, antenna profile effects and interference   sources in order to provide a realistic environment for wireless experimentation</li> <li>uses the most CPU for every packet, as complex calculations are used for fidelity</li> <li>See Wiki for details on general EMANE usage</li> <li>See CORE EMANE for details on using EMANE in CORE</li> </ul> </li> </ul> Model Type Supported Platform(s) Fidelity Description WLAN On/Off Linux Low Ethernet bridging with nftables Wireless On/Off Linux Medium Ethernet bridging with nftables EMANE RF Linux High TAP device connected to EMANE emulator with pluggable MAC and PHY radio types"},{"location":"gui.html#example-wlan-network-setup","title":"Example WLAN Network Setup","text":"<p>To quickly build a wireless network, you can first place several router nodes onto the canvas. If you have the Quagga MDR software installed, it is recommended that you use the mdr node type for reduced routing overhead. Next choose the WLAN from the Link-layer nodes submenu. First set the desired WLAN parameters by double-clicking the cloud icon. Then you can link all selected right-clicking on the WLAN and choosing Link to Selected.</p> <p>Linking a router to the WLAN causes a small antenna to appear, but no red link line is drawn. Routers can have multiple wireless links and both wireless and wired links (however, you will need to manually configure route redistribution.) The mdr node type will generate a routing configuration that enables OSPFv3 with MANET extensions. This is a Boeing-developed extension to Quagga's OSPFv3 that reduces flooding overhead and optimizes the flooding procedure for mobile ad-hoc (MANET) networks.</p> <p>The default configuration of the WLAN is set to use the basic range model. Having this model selected causes core-daemon to calculate the distance between nodes based on screen pixels. A numeric range in screen pixels is set for the wireless network using the Range slider. When two wireless nodes are within range of each other, a green line is drawn between them and they are linked. Two wireless nodes that are farther than the range pixels apart are not linked. During Execute mode, users may move wireless nodes around by clicking and dragging them, and wireless links will be dynamically made or broken.</p>"},{"location":"gui.html#running-commands-within-nodes","title":"Running Commands within Nodes","text":"<p>You can double click a node to bring up a terminal for running shell commands. Within the terminal you can run anything you like and those commands will be run in context of the node. For standard CORE nodes, the only thing to keep in mind is that you are using the host file system and anything you change or do can impact the greater system. By default, your terminal will open within the nodes home directory for the running session, but it is temporary and will be removed when the session is stopped.</p>"},{"location":"gui.html#mobility-scripting","title":"Mobility Scripting","text":"<p>CORE has a few ways to script mobility.</p> Option Description ns-2 script The script specifies either absolute positions or waypoints with a velocity. Locations are given with Cartesian coordinates. gRPC API An external entity can move nodes by leveraging the gRPC API EMANE events See EMANE for details on using EMANE scripts to move nodes around. Location information is typically given as latitude, longitude, and altitude. <p>For the first method, you can create a mobility script using a text editor, or using a tool such as BonnMotion, and associate the script with one of the wireless using the WLAN configuration dialog box. Click the ns-2 mobility script... button, and set the mobility script file field in the resulting ns2script configuration dialog.</p> <p>Here is an example for creating a BonnMotion script for 10 nodes:</p> <pre><code>bm -f sample RandomWaypoint -n 10 -d 60 -x 1000 -y 750\nbm NSFile -f sample\n# use the resulting 'sample.ns_movements' file in CORE\n</code></pre> <p>When the Execute mode is started and one of the WLAN nodes has a mobility script, a mobility script window will appear. This window contains controls for starting, stopping, and resetting the running time for the mobility script. The loop checkbox causes the script to play continuously. The resolution text box contains the number of milliseconds between each timer event; lower values cause the mobility to appear smoother but consumes greater CPU time.</p> <p>The format of an ns-2 mobility script looks like:</p> <pre><code># nodes: 3, max time: 35.000000, max x: 600.00, max y: 600.00\n$node_(2) set X_ 144.0\n$node_(2) set Y_ 240.0\n$node_(2) set Z_ 0.00\n$ns_ at 1.00 \"$node_(2) setdest 130.0 280.0 15.0\"\n</code></pre> <p>The first three lines set an initial position for node 2. The last line in the above example causes node 2 to move towards the destination (130, 280) at speed 15. All units are screen coordinates, with speed in units per second. The total script time is learned after all nodes have reached their waypoints. Initially, the time slider in the mobility script dialog will not be accurate.</p> <p>Examples mobility scripts (and their associated topology files) can be found in the configs/ directory.</p>"},{"location":"gui.html#alerts","title":"Alerts","text":"<p>The alerts button is located in the bottom right-hand corner of the status bar in the CORE GUI. This will change colors to indicate one or more problems with the running emulation. Clicking on the alerts button will invoke the alerts dialog.</p> <p>The alerts dialog contains a list of alerts received from the CORE daemon. An alert has a time, severity level, optional node number, and source. When the alerts button is red, this indicates one or more fatal exceptions. An alert with a fatal severity level indicates that one or more of the basic pieces of emulation could not be created, such as failure to create a bridge or namespace, or the failure to launch EMANE processes for an EMANE-based network.</p> <p>Clicking on an alert displays details for that alert. The alert source is a text string to help trace where the alert occurred; \"service:UserDefined\" for example, would appear for a failed validation command with the UserDefined service.</p> <p>A button is available at the bottom of the dialog for clearing the alert list.</p>"},{"location":"gui.html#customizing-your-topologys-look","title":"Customizing your Topology's Look","text":"<p>Several annotation tools are provided for changing the way your topology is presented. Captions may be added with the Text tool. Ovals and rectangles may be drawn in the background, helpful for visually grouping nodes together.</p> <p>During live demonstrations the marker tool may be helpful for drawing temporary annotations on the canvas that may be quickly erased. A size and color palette appears at the bottom of the toolbar when the marker tool is selected. Markings are only temporary and are not saved in the topology file.</p> <p>The basic node icons can be replaced with a custom image of your choice. Icons appear best when they use the GIF or PNG format with a transparent background. To change a node's icon, double-click the node to invoke its configuration dialog and click on the button to the right of the node name that shows the node's current icon.</p> <p>A background image for the canvas may be set using the Wallpaper... option from the Canvas menu. The image may be centered, tiled, or scaled to fit the canvas size. An existing terrain, map, or network diagram could be used as a background, for example, with CORE nodes drawn on top.</p>"},{"location":"hitl.html","title":"Hardware In The Loop","text":""},{"location":"hitl.html#overview","title":"Overview","text":"<p>In some cases it may be impossible or impractical to run software using CORE nodes alone. You may need to bring in external hardware into the network. CORE's emulated networks run in real time, so they can be connected to live physical networks. The RJ45 tool and the Tunnel tool help with connecting to the real world. These tools are available from the Link Layer Nodes menu.</p> <p>When connecting two or more CORE emulations together, MAC address collisions should be avoided. CORE automatically assigns MAC addresses to interfaces when the emulation is started, starting with 00:00:00:aa:00:00 and incrementing the bottom byte. The starting byte should be changed on the second CORE machine using the Tools-&gt;MAC Addresses option the menu.</p>"},{"location":"hitl.html#rj45-node","title":"RJ45 Node","text":"<p>CORE provides the RJ45 node, which represents a physical interface within the host that is running CORE. Any real-world network devices can be connected to the interface and communicate with the CORE nodes in real time.</p> <p>The main drawback is that one physical interface is required for each connection. When the physical interface is assigned to CORE, it may not be used for anything else. Another consideration is that the computer or network that you are connecting to must be co-located with the CORE machine.</p>"},{"location":"hitl.html#gui-usage","title":"GUI Usage","text":"<p>To place an RJ45 connection, click on the Link Layer Nodes toolbar and select the RJ45 Node from the options. Click on the canvas, where you would like the nodes to place. Now click on the Link Tool and draw a link between the RJ45 and the other node you wish to be connected to. The RJ45 node will display \"UNASSIGNED\". Double-click the RJ45 node to assign a physical interface. A list of available interfaces will be shown, and one may be selected, then selecting Apply.</p> <p>Note</p> <p>When you press the Start button to instantiate your topology, the interface assigned to the RJ45 will be connected to the CORE topology. The interface can no longer be used by the system.</p>"},{"location":"hitl.html#multiple-rj45s-with-one-interface-vlan","title":"Multiple RJ45s with One Interface (VLAN)","text":"<p>It is possible to have multiple RJ45 nodes using the same physical interface by leveraging 802.1x VLANs. This allows for more RJ45 nodes than physical ports are available, but the (e.g. switching) hardware connected to the physical port must support the VLAN tagging, and the available bandwidth will be shared.</p> <p>You need to create separate VLAN virtual devices on the Linux host, and then assign these devices to RJ45 nodes inside of CORE. The VLANing is actually performed outside of CORE, so when the CORE emulated node receives a packet, the VLAN tag will already be removed.</p> <p>Here are example commands for creating VLAN devices under Linux:</p> <pre><code>ip link add link eth0 name eth0.1 type vlan id 1\nip link add link eth0 name eth0.2 type vlan id 2\nip link add link eth0 name eth0.3 type vlan id 3\n</code></pre>"},{"location":"hitl.html#tunnel-tool","title":"Tunnel Tool","text":"<p>The tunnel tool builds GRE tunnels between CORE emulations or other hosts. Tunneling can be helpful when the number of physical interfaces is limited or when the peer is located on a different network. In this case a physical interface does not need to be dedicated to CORE as with the RJ45 tool.</p> <p>The peer GRE tunnel endpoint may be another CORE machine or another host that supports GRE tunneling. When placing a Tunnel node, initially the node will display \"UNASSIGNED\". This text should be replaced with the IP address of the tunnel peer. This is the IP address of the other CORE machine or physical machine, not an IP address of another virtual node.</p> <p>Note</p> <p>Be aware of possible MTU (Maximum Transmission Unit) issues with GRE devices. The gretap device has an interface MTU of 1,458 bytes; when joined to a Linux bridge, the bridge's MTU becomes 1,458 bytes. The Linux bridge will not perform fragmentation for large packets if other bridge ports have a higher MTU such as 1,500 bytes.</p> <p>The GRE key is used to identify flows with GRE tunneling. This allows multiple GRE tunnels to exist between that same pair of tunnel peers. A unique number should be used when multiple tunnels are used with the same peer. When configuring the peer side of the tunnel, ensure that the matching keys are used.</p>"},{"location":"hitl.html#example-usage","title":"Example Usage","text":"<p>Here are example commands for building the other end of a tunnel on a Linux machine. In this example, a router in CORE has the virtual address 10.0.0.1/24 and the CORE host machine has the (real) address 198.51.100.34/24. The Linux box that will connect with the CORE machine is reachable over the (real) network at 198.51.100.76/24. The emulated router is linked with the Tunnel Node. In the Tunnel Node configuration dialog, the address 198.51.100.76 is entered, with the key set to 1. The gretap interface on the Linux box will be assigned an address from the subnet of the virtual router node, 10.0.0.2/24.</p> <pre><code># these commands are run on the tunnel peer\nsudo ip link add gt0 type gretap remote 198.51.100.34 local 198.51.100.76 key 1\nsudo ip addr add 10.0.0.2/24 dev gt0\nsudo ip link set dev gt0 up\n</code></pre> <p>Now the virtual router should be able to ping the Linux machine:</p> <pre><code># from the CORE router node\nping 10.0.0.2\n</code></pre> <p>And the Linux machine should be able to ping inside the CORE emulation:</p> <pre><code># from the tunnel peer\nping 10.0.0.1\n</code></pre> <p>To debug this configuration, tcpdump can be run on the gretap devices, or on the physical interfaces on the CORE or Linux machines. Make sure that a firewall is not blocking the GRE traffic.</p>"},{"location":"install.html","title":"Installation","text":"<p>Warning</p> <p>If Docker is installed, the default iptable rules will block CORE traffic</p>"},{"location":"install.html#overview","title":"Overview","text":"<p>This page will provide details on various options that can be used when installing CORE.</p>"},{"location":"install.html#complete-examples","title":"Complete Examples","text":"<p>For complete examples installing CORE, OSPF MDR, EMANE, and the EMANE python bindings, see the pages below. The distros below are targeted to align with provided EMANE built packages.</p> <ul> <li>Installing on Ubuntu 22.04</li> <li>Installing on Rocky Linux 8.10</li> </ul>"},{"location":"install.html#requirements","title":"Requirements","text":"<p>Any computer capable of running Linux should be able to run CORE. Since the physical machine will be hosting numerous containers, as a general rule you should select a machine having as much RAM and CPU resources as possible.</p> <ul> <li>Linux Kernel v3.3+</li> <li>Python 3.10+</li> <li>pip</li> <li>venv</li> <li>tcl/tk support for GUI</li> <li>iproute2 4.5+ is a requirement for bridge related commands</li> <li>nftables compatible kernel and nft command line tool</li> </ul>"},{"location":"install.html#files","title":"Files","text":"<p>The following is a list of files that would be installed after installation.</p> <ul> <li>executables<ul> <li><code>&lt;prefix&gt;/bin/{vcmd, vnode}</code></li> <li>can be adjusted using script based install , package will be /usr</li> </ul> </li> <li>python files<ul> <li>virtual environment <code>/opt/core/venv</code></li> <li>local install will be local to the python version used<ul> <li><code>python3 -c \"import core; print(core.__file__)\"</code></li> </ul> </li> <li>scripts {core-daemon, core-cleanup, etc}<ul> <li>virtualenv <code>/opt/core/venv/bin</code></li> <li>local <code>/usr/local/bin</code></li> </ul> </li> </ul> </li> <li>configuration files<ul> <li><code>/opt/core/etc/{core.conf, logging.conf}</code></li> </ul> </li> <li>examples, tutorials, and data files<ul> <li><code>/opt/core/share</code></li> </ul> </li> <li>ospf mdr repository files when using script based install<ul> <li><code>&lt;repo&gt;/../ospf-mdr</code></li> </ul> </li> </ul>"},{"location":"install.html#installed-scripts","title":"Installed Scripts","text":"<p>The following python scripts are provided.</p> Name Description core-cleanup tool to help removed lingering core created containers, bridges, directories core-cli tool to query, open xml files, and send commands using gRPC core-daemon runs the backed core server providing a gRPC API core-gui starts GUI core-python provides a convenience for running the core python virtual environment core-route-monitor tool to help monitor traffic across nodes and feed that to SDT core-service-update tool to update automate modifying a legacy service to match current naming"},{"location":"install.html#upgrading-from-older-release","title":"Upgrading from Older Release","text":"<p>Please make sure to uninstall any previous installations of CORE cleanly before proceeding to install.</p> <p>Clearing out a current install from 7.0.0+, making sure to provide options used for install (<code>-l</code> or <code>-p</code>).</p> <pre><code>cd &lt;CORE_REPO&gt;\ninv uninstall &lt;options&gt;\n</code></pre> <p>Previous install was built from source for CORE release older than 7.0.0:</p> <pre><code>cd &lt;CORE_REPO&gt;\nsudo make uninstall\nmake clean\n./bootstrap.sh clean\n</code></pre> <p>Installed from previously built packages:</p> <pre><code># centos\nsudo yum remove core\n# ubuntu\nsudo apt remove core\n</code></pre>"},{"location":"install.html#package-based-install","title":"Package Based Install","text":"<p>Starting with 9.0.0 there are pre-built rpm/deb packages. You can retrieve the rpm/deb package from releases page.</p> <p>The built packages will require and install system level dependencies, as well as running a post install script to install the provided CORE python wheel. A similar uninstall script is ran when uninstalling and would require the same options as given, during the install.</p> <p>Note</p> <p>PYTHON defaults to python3 for installs below, CORE requires python3.9+, pip, tk compatibility for python gui, and venv for virtual environments</p> <p>Examples for install:</p> <pre><code># recommended to upgrade to the latest version of pip before installation\n# in python, can help avoid building from source issues\nsudo &lt;python&gt; -m pip install --upgrade pip\n# install vcmd/vnoded, system dependencies,\n# and core python into a venv located at /opt/core/venv\nsudo &lt;yum/apt&gt; install -y ./&lt;package&gt;\n# disable the venv and install to python directly\nsudo NO_VENV=1 &lt;yum/apt&gt; install -y ./&lt;package&gt;\n# change python executable used to install for venv or direct installations\nsudo PYTHON=python3.9 &lt;yum/apt&gt; install -y ./&lt;package&gt;\n# disable venv and change python executable\nsudo NO_VENV=1 PYTHON=python3.9 &lt;yum/apt&gt; install -y ./&lt;package&gt;\n# skip installing the python portion entirely, as you plan to carry this out yourself\n# core python wheel is located at /opt/core/core-&lt;version&gt;-py3-none-any.whl\nsudo NO_PYTHON=1 &lt;yum/apt&gt; install -y ./&lt;package&gt;\n# install python wheel into python of your choosing\nsudo &lt;python&gt; -m pip install /opt/core/core-&lt;version&gt;-py3-none-any.whl\n</code></pre> <p>Example for removal, requires using the same options as install:</p> <pre><code># remove a standard install\nsudo &lt;yum/apt&gt; remove core\n# remove a local install\nsudo NO_VENV=1 &lt;yum/apt&gt; remove core\n# remove install using alternative python\nsudo PYTHON=python3.9 &lt;yum/apt&gt; remove core\n# remove install using alternative python and local install\nsudo NO_VENV=1 PYTHON=python3.9 &lt;yum/apt&gt; remove core\n# remove install and skip python uninstall\nsudo NO_PYTHON=1 &lt;yum/apt&gt; remove core\n</code></pre>"},{"location":"install.html#installing-ospf-mdr","title":"Installing OSPF MDR","text":"<p>You will need to manually install OSPF MDR for routing nodes, since this is not provided by the package.</p> <pre><code>git clone https://github.com/USNavalResearchLaboratory/ospf-mdr.git\ncd ospf-mdr\n./bootstrap.sh\n./configure --disable-doc --enable-user=root --enable-group=root \\\n  --with-cflags=-ggdb --sysconfdir=/usr/local/etc/quagga --enable-vtysh \\\n  --localstatedir=/var/run/quagga\nmake -j$(nproc)\nsudo make install\n</code></pre> <p>When done see Post Install.</p>"},{"location":"install.html#script-based-install","title":"Script Based Install","text":"<p>The script based installation will install system level dependencies, python library and dependencies, as well as dependencies for building CORE.</p> <p>The script based install also automatically builds and installs OSPF MDR, used by default on routing nodes. This can optionally be skipped.</p> <p>Installaion will carry out the following steps:</p> <ul> <li>installs system dependencies for building core</li> <li>builds vcmd/vnoded and python grpc files</li> <li>installs core into poetry managed virtual environment or locally, if flag is passed</li> <li>installs systemd service pointing to appropriate python location based on install type</li> <li>clone/build/install working version of OPSF MDR</li> </ul> <p>Note</p> <p>Installing locally comes with its own risks, it can result it potential dependency conflicts with system package manager installed python dependencies</p> <p>Note</p> <p>Provide a prefix that will be found on path when running as sudo, if the default prefix /usr/local will not be valid</p> <p>The following tools will be leveraged during installation:</p> Tool Description pip used to install pipx pipx used to install standalone python tools (invoke, poetry) invoke used to run provided tasks (install, uninstall, reinstall, etc) poetry used to install python virtual environment or building a python wheel <p>First we will need to clone and navigate to the CORE repo.</p> <pre><code># clone CORE repo\ngit clone https://github.com/coreemu/core.git\ncd core\n\n# install dependencies to run installation task\n./setup.sh\n# skip installing system packages, due to using python built from source\nNO_SYSTEM=1 ./setup.sh\n\n# run the following or open a new terminal\nsource ~/.bashrc\n\n# Ubuntu\ninv install\n# CentOS\ninv install -p /usr\n# optionally skip python system packages\ninv install --no-python\n# optionally skip installing ospf mdr\ninv install --no-ospf\n\n# install command options\nUsage: inv[oke] [--core-opts] install [--options] [other tasks here ...]\n\nDocstring:\n  install core, poetry, scripts, service, and ospf mdr\n\nOptions:\n  -d, --dev                          install development mode\n  -i STRING, --install-type=STRING   used to force an install type, can be one of the following (redhat, debian)\n  -l, --local                        determines if core will install to local system, default is False\n  -n, --no-python                    avoid installing python system dependencies\n  -o, --[no-]ospf                    disable ospf installation\n  -p STRING, --prefix=STRING         prefix where scripts are installed, default is /usr/local\n  -v, --verbose\n</code></pre> <p>When done see Post Install.</p>"},{"location":"install.html#unsupported-linux-distribution","title":"Unsupported Linux Distribution","text":"<p>For unsupported OSs you could attempt to do the following to translate an installation to your use case.</p> <ul> <li>make sure you have python3.9+ with venv support</li> <li>make sure you have python3 invoke available to leverage <code>&lt;repo&gt;/tasks.py</code></li> </ul> <pre><code># this will print the commands that would be ran for a given installation\n# type without actually running them, they may help in being used as\n# the basis for translating to your OS\ninv install --dry -v -p &lt;prefix&gt; -i &lt;install type&gt;\n</code></pre>"},{"location":"install.html#installing-emane","title":"Installing EMANE","text":"<p>Note</p> <p>Installing EMANE for the virtual environment is known to work for 1.21+</p> <p>The recommended way to install EMANE is using prebuilt packages, otherwise you can follow their instructions for installing from source. Installation information can be found here.</p> <p>There is an invoke task to help install the EMANE bindings into the CORE virtual environment, when needed. An example for running the task is below and the version provided should match the version of the packages installed.</p> <p>You will also need to make sure, you are providing the correct python binary where CORE is being used.</p> <p>Also, these EMANE bindings need to be built using <code>protoc</code> 3.19+. So make sure that is available and being picked up on PATH properly.</p> <p>Examples for building and installing EMANE python bindings for use in CORE:</p> <pre><code># if your system does not have protoc 3.19+\nwget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.6/protoc-3.19.6-linux-x86_64.zip\nmkdir protoc\nunzip protoc-3.19.6-linux-x86_64.zip -d protoc\ngit clone https://github.com/adjacentlink/emane.git\ncd emane\ngit checkout v1.3.3\n./autogen.sh\nPYTHON=/opt/core/venv/bin/python ./configure --prefix=/usr\ncd src/python\nPATH=/opt/protoc/bin:$PATH make\n/opt/core/venv/bin/python -m pip install .\n\n# when your system has protoc 3.19+\ncd &lt;CORE_REPO&gt;\n# example version tag v1.3.3\n# overriding python used to leverage the default virtualenv install\nPYTHON=/opt/core/venv/bin/python inv install-emane -e &lt;version tag&gt;\n# local install that uses whatever python3 refers to\ninv install-emane -e &lt;version tag&gt;\n</code></pre>"},{"location":"install.html#post-install","title":"Post Install","text":"<p>After installation completes you are now ready to run CORE.</p>"},{"location":"install.html#resolving-docker-issues","title":"Resolving Docker Issues","text":"<p>If you have Docker installed, by default it will change the iptables forwarding chain to drop packets, which will cause issues for CORE traffic.</p> <p>You can temporarily resolve the issue with the following command:</p> <pre><code>sudo iptables --policy FORWARD ACCEPT\n</code></pre> <p>Alternatively, you can configure Docker to avoid doing this, but will likely break normal Docker networking usage. Using the setting below will require a restart.</p> <p>Place the file contents below in /etc/docker/docker.json</p> <pre><code>{\n  \"iptables\": false\n}\n</code></pre>"},{"location":"install.html#running-core","title":"Running CORE","text":"<p>In typical usage CORE is made up of two parts, the core-daemon (server) and the core-gui (client).</p> <pre><code># in one terminal run the server daemon\nsudo core-daemon\n# in another terminal run the gui client\ncore-gui\n</code></pre>"},{"location":"install.html#enabling-service","title":"Enabling Service","text":"<p>After installation, the core service is not enabled by default. If you desire to use the service, run the following commands.</p> <pre><code>sudo systemctl enable core-daemon\nsudo systemctl start core-daemon\n</code></pre>"},{"location":"install_docker.html","title":"Install Docker","text":""},{"location":"install_docker.html#overview","title":"Overview","text":"<p>CORE can be installed into and ran from a Docker container. This section will cover how you can build and run CORE from a Docker based image.</p>"},{"location":"install_docker.html#build-image","title":"Build Image","text":"<p>You can leverage one of the provided Dockerfiles to build a CORE based image. Since CORE nodes will leverage software available within the system for a given use case, make sure to update and build the Dockerfile with desired software.</p> <p>The example Dockerfiles are not meant to be an end all solution, but a solid starting point for running CORE.</p> <p>Provided Dockerfiles:</p> <ul> <li>Dockerfile.emane-python - Build EMANE python bindings for use in files below</li> <li>Dockerfile.rocky - Rocky Linux 8, CORE from latest package, OSPF MDR, and EMANE</li> <li>Dockerfile.ubuntu - Ubuntu 22.04, CORE from latest package, OSPF MDR, and EMANE</li> </ul> <pre><code># clone core\ngit clone https://github.com/coreemu/core.git\ncd core\n# first you must build EMANE python bindings\nsudo docker build -t emane-python -f dockerfiles/Dockerfile.emane-python .\n# build desired CORE image, OSPF is a build stage dependency within the file\nsudo docker build -t core -f dockerfiles/&lt;Dockerfile&gt; .\n</code></pre>"},{"location":"install_docker.html#run-container","title":"Run Container","text":"<p>There are some required parameters when starting a CORE based Docker container for CORE to function properly. These are shown below in the run command.</p> <pre><code># start container into the background and run the core-daemon by default\nsudo docker run -itd --name core -e DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:rw \\\n    --privileged --init --entrypoint /opt/core/venv/bin/core-daemon core\n# enable xhost access to the root user, this will allow you to run the core-gui from the container\nxhost +local:root\n# launch core-gui from the running container launched previously\nsudo docker exec -it core core-gui\n</code></pre>"},{"location":"install_rocky.html","title":"Install Rocky","text":""},{"location":"install_rocky.html#overview","title":"Overview","text":"<p>This helps provide an example for installation into a Rocky Linux 8.10 environment. Both of the examples below will install CORE into its own virtual environment located at /opt/core/venv. Both examples below also assume using ~/Documents as the working directory.</p>"},{"location":"install_rocky.html#install","title":"Install","text":"<p>This section covers step by step commands that can be used to install CORE using the package based installation path. This will require downloading a package from the release page, to use during the install CORE step below.</p> <pre><code># install system packages\nsudo dnf -y update\nsudo dnf install -y \\\n    xterm \\\n    wget \\\n    tcpdump \\\n    python3.12 \\\n    python3.12-tkinter \\\n    iproute-tc\n\n# install ospf mdr\ncd ~/Documents\nsudo dnf install -y \\\n    automake \\\n    gcc-c++ \\\n    libtool \\\n    make \\\n    pkg-config \\\n    readline-devel \\\n    git\ngit clone https://github.com/USNavalResearchLaboratory/ospf-mdr.git\ncd ospf-mdr\n./bootstrap.sh\n./configure --disable-doc --enable-user=root --enable-group=root \\\n    --with-cflags=-ggdb --sysconfdir=/usr/local/etc/quagga --enable-vtysh \\\n    --localstatedir=/var/run/quagga\nmake -j$(nproc)\nsudo make install\n\n# install emane\ncd ~/Documents\nEMANE_VERSION=1.5.2\nEMANE_RELEASE=emane-${EMANE_VERSION}-release-1\nEMANE_PACKAGE=${EMANE_RELEASE}.el8.x86_64.tar.gz\nwget -q https://adjacentlink.com/downloads/emane/${EMANE_PACKAGE}\ntar xf ${EMANE_PACKAGE}\ncd ${EMANE_RELEASE}/rpms/el8/x86_64\nrm emane-spectrum-tools-*.rpm emane-model-lte*.rpm\nrm *devel*.rpm\nsudo dnf install -y ./emane*.rpm ./python3-emane-${EMANE_VERSION}-1.el8.noarch.rpm\n\n# install core\ncd ~/Documents\nCORE_PACKAGE=core_9.2.0_x86_64.rpm\nPACKAGE_URL=https://github.com/coreemu/core/releases/latest/download/${CORE_PACKAGE}\nwget -q ${PACKAGE_URL}\nPYTHON=python3.12 dnf install -y ./${CORE_PACKAGE}\n\n# install emane python bindings into CORE virtual environment\ncd ~/Documents\nsudo dnf install -y dnf-plugins-core\nsudo dnf config-manager --set-enabled devel\nsudo dnf update -y\nsudo dnf install -y \\\n    protobuf-devel \\\n    libxml2-devel \\\n    pcre-devel \\\n    libuuid-devel \\\n    libpcap-devel\nwget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.6/protoc-3.19.6-linux-x86_64.zip\nmkdir protoc\nunzip protoc-3.19.6-linux-x86_64.zip -d protoc\ngit clone https://github.com/adjacentlink/emane.git\ncd emane\ngit checkout v${EMANE_VERSION}\n./autogen.sh\nPYTHON=/opt/core/venv/bin/python ./configure --prefix=/usr\ncd src/python\nPATH=~/Documents/protoc/bin:$PATH make\nsudo /opt/core/venv/bin/python -m pip install .\n</code></pre>"},{"location":"install_rocky.html#running-core","title":"Running CORE","text":"<p>This install will place CORE within a virtual environment, symlinks to CORE scripts will be added to /usr/bin.</p> <pre><code># in one terminal run the server daemon\nsudo core-daemon\n# in another terminal run the gui client\ncore-gui\n</code></pre>"},{"location":"install_ubuntu.html","title":"Install Ubuntu","text":""},{"location":"install_ubuntu.html#overview","title":"Overview","text":"<p>Below is a detailed path for installing CORE and related tooling on a fresh Ubuntu 22.04 installation. Both of the examples below will install CORE into its own virtual environment located at /opt/core/venv. Both examples below also assume using ~/Documents as the working directory.</p>"},{"location":"install_ubuntu.html#install","title":"Install","text":"<p>This section covers step by step commands that can be used to install CORE using the package based installation path. This will require downloading a package from the release page, to use during the install CORE step below.</p> <pre><code># install system packages\nsudo apt-get update -y\nsudo apt-get install -y \\\n    ca-certificates \\\n    xterm \\\n    psmisc \\\n    python3 \\\n    python3-tk \\\n    python3-pip \\\n    python3-venv \\\n    wget \\\n    iproute2 \\\n    iputils-ping \\\n    tcpdump\n\n# install ospf mdr\ncd ~/Documents\nsudo apt-get install -y \\\n    automake \\\n    gawk \\\n    g++ \\\n    libreadline-dev \\\n    libtool \\\n    make \\\n    pkg-config \\\n    git\ngit clone https://github.com/USNavalResearchLaboratory/ospf-mdr.git\ncd ospf-mdr\n./bootstrap.sh\n./configure --disable-doc --enable-user=root --enable-group=root \\\n    --with-cflags=-ggdb --sysconfdir=/usr/local/etc/quagga --enable-vtysh \\\n    --localstatedir=/var/run/quagga\nmake -j$(nproc)\nsudo make install\n\n# install emane\ncd ~/Documents\nEMANE_RELEASE=emane-1.5.1-release-1\nEMANE_PACKAGE=${EMANE_RELEASE}.ubuntu-22_04.amd64.tar.gz\nwget -q https://adjacentlink.com/downloads/emane/${EMANE_PACKAGE}\ntar xf ${EMANE_PACKAGE}\ncd ${EMANE_RELEASE}/debs/ubuntu-22_04/amd64\nrm emane-spectrum-tools*.deb emane-model-lte*.deb\nrm *dev*.deb\nsudo apt-get install -y ./emane*.deb ./python3-emane_*.deb\n\n# install core\ncd ~/Documents\nCORE_PACKAGE=core_9.2.0_amd64.deb\nPACKAGE_URL=https://github.com/coreemu/core/releases/latest/download/${CORE_PACKAGE}\nwget -q ${PACKAGE_URL}\nsudo apt-get install -y ./${CORE_PACKAGE}\n\n# install emane python bindings\ncd ~/Documents\nsudo apt-get install -y \\\n    unzip \\\n    libpcap-dev \\\n    libpcre3-dev \\\n    libprotobuf-dev \\\n    libxml2-dev \\\n    protobuf-compiler \\\n    uuid-dev\nwget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.6/protoc-3.19.6-linux-x86_64.zip\nmkdir protoc\nunzip protoc-3.19.6-linux-x86_64.zip -d protoc\ngit clone https://github.com/adjacentlink/emane.git\ncd emane\ngit checkout v1.5.1\n./autogen.sh\n./configure --prefix=/usr\ncd src/python\nPATH=~/Documents/protoc/bin:$PATH make\nsudo /opt/core/venv/bin/python -m pip install .\n</code></pre>"},{"location":"install_ubuntu.html#running-core","title":"Running CORE","text":"<p>This install will place CORE within a virtual environment, symlinks to CORE scripts will be added to /usr/bin.</p> <pre><code># in one terminal run the server daemon\nsudo core-daemon\n# in another terminal run the gui client\ncore-gui\n</code></pre>"},{"location":"nodetypes.html","title":"Node Types","text":""},{"location":"nodetypes.html#overview","title":"Overview","text":"<p>Different node types can be used within CORE, each with their own tradeoffs and functionality.</p>"},{"location":"nodetypes.html#core-nodes","title":"CORE Nodes","text":"<p>CORE nodes are the standard node type typically used in CORE. They are backed by Linux network namespaces. They use very little system resources in order to emulate a network. They do however share the hosts file system as they do not get their own. CORE nodes will have a directory uniquely created for them as a place to keep their files and mounted directories (<code>/tmp/pycore.&lt;session id&gt;/&lt;node name.conf</code>), which will usually be wiped and removed upon shutdown.</p>"},{"location":"nodetypes.html#docker-nodes","title":"Docker Nodes","text":"<p>Docker nodes provide a convenience for running nodes using predefind images and filesystems that CORE nodes do not provide. Details for using Docker nodes can be found here.</p>"},{"location":"nodetypes.html#physical-nodes","title":"Physical Nodes","text":"<p>The physical machine type is used for nodes that represent a real Linux-based machine that will participate in the emulated network scenario. This is typically used, for example, to incorporate racks of server machines from an emulation testbed. A physical node is one that is running the CORE daemon (core-daemon), but will not be further partitioned into containers. Services that are run on the physical node do not run in an isolated environment, but directly on the operating system.</p> <p>Physical nodes must be assigned to servers, the same way nodes are assigned to emulation servers with Distributed Emulation. The list of available physical nodes currently shares the same dialog box and list as the emulation servers, accessed using the Emulation Servers... entry from the Session menu.</p> <p>Support for physical nodes is under development and may be improved in future releases. Currently, when any node is linked to a physical node, a dashed line is drawn to indicate network tunneling. A GRE tunneling interface will be created on the physical node and used to tunnel traffic to and from the emulated world.</p> <p>Double-clicking on a physical node during runtime opens a terminal with an SSH shell to that node. Users should configure public-key SSH login as done with emulation servers.</p>"},{"location":"performance.html","title":"CORE Performance","text":""},{"location":"performance.html#overview","title":"Overview","text":"<p>The top question about the performance of CORE is often how many nodes can it handle? The answer depends on several factors:</p> Factor Performance Impact Hardware the number and speed of processors in the computer, the available processor cache, RAM memory, and front-side bus speed may greatly affect overall performance. Operating system version distribution of Linux and the specific kernel versions used will affect overall performance. Active processes all nodes share the same CPU resources, so if one or more nodes is performing a CPU-intensive task, overall performance will suffer. Network traffic the more packets that are sent around the virtual network increases the amount of CPU usage. GUI usage widgets that run periodically, mobility scenarios, and other GUI interactions generally consume CPU cycles that may be needed for emulation. <p>On a typical single-CPU Xeon 3.0GHz server machine with 2GB RAM running Linux, we have found it reasonable to run 30-75 nodes running OSPFv2 and OSPFv3 routing. On this hardware CORE can instantiate 100 or more nodes, but at that point it becomes critical as to what each of the nodes is doing.</p> <p>Because this software is primarily a network emulator, the more appropriate question is how much network traffic can it handle? On the same 3.0GHz server described above, running Linux, about 300,000 packets-per-second can be pushed through the system. The number of hops and the size of the packets is less important. The limiting factor is the number of times that the operating system needs to handle a packet. The 300,000 pps figure represents the number of times the system as a whole needed to deal with a packet. As more network hops are added, this increases the number of context switches and decreases the throughput seen on the full length of the network path.</p> <p>Note</p> <p>The right question to be asking is \"how much traffic?\", not \"how many nodes?\".</p> <p>For a more detailed study of performance in CORE, refer to the following publications:</p> <ul> <li>J. Ahrenholz, T. Goff, and B. Adamson, Integration of the CORE and EMANE   Network Emulators, Proceedings of the IEEE Military Communications Conference 2011, November 2011.</li> <li>Ahrenholz, J., Comparison of CORE Network Emulation Platforms, Proceedings   of the IEEE Military Communications Conference 2010, pp. 864-869, November 2010.</li> <li>J. Ahrenholz, C. Danilov, T. Henderson, and J.H. Kim, CORE: A real-time   network emulator, Proceedings of IEEE MILCOM Conference, 2008.</li> </ul>"},{"location":"python.html","title":"Python API","text":""},{"location":"python.html#overview","title":"Overview","text":"<p>Writing your own Python scripts offers a rich programming environment with complete control over all aspects of the emulation.</p> <p>The scripts need to be ran with root privileges because they create new network namespaces. In general, a CORE Python script does not connect to the CORE daemon, in fact the core-daemon is just another Python script that uses the CORE Python modules and exchanges messages with the GUI.</p>"},{"location":"python.html#examples","title":"Examples","text":""},{"location":"python.html#node-models","title":"Node Models","text":"<p>When creating nodes of type <code>core.nodes.base.CoreNode</code> these are the default models and the services they map to.</p> <ul> <li>mdr<ul> <li>zebra, OSPFv3MDR, IPForward</li> </ul> </li> <li>PC<ul> <li>DefaultRoute</li> </ul> </li> <li>router<ul> <li>zebra, OSPFv2, OSPFv3, IPForward</li> </ul> </li> <li>host<ul> <li>DefaultRoute, SSH</li> </ul> </li> </ul>"},{"location":"python.html#interface-helper","title":"Interface Helper","text":"<p>There is an interface helper class that can be leveraged for convenience when creating interface data for nodes. Alternatively one can manually create a <code>core.emulator.data.InterfaceData</code> class instead with appropriate information.</p> <p>Manually creating interface data:</p> <pre><code>from core.emulator.data import InterfaceData\n\n# id is optional and will set to the next available id\n# name is optional and will default to eth&lt;id&gt;\n# mac is optional and will result in a randomly generated mac\niface_data = InterfaceData(\n    id=0,\n    name=\"eth0\",\n    ip4=\"10.0.0.1\",\n    ip4_mask=24,\n    ip6=\"2001::\",\n    ip6_mask=64,\n)\n</code></pre> <p>Leveraging the interface prefixes helper class:</p> <pre><code>from core.emulator.data import IpPrefixes\n\nip_prefixes = IpPrefixes(ip4_prefix=\"10.0.0.0/24\", ip6_prefix=\"2001::/64\")\n# node is used to get an ip4/ip6 address indexed from within the above prefixes\n# name is optional and would default to eth&lt;id&gt;\n# mac is optional and will result in a randomly generated mac\niface_data = ip_prefixes.create_iface(\n    node=node, name=\"eth0\", mac=\"00:00:00:00:aa:00\"\n)\n</code></pre>"},{"location":"python.html#listening-to-events","title":"Listening to Events","text":"<p>Various events that can occur within a session can be listened to.</p> <p>Event types:</p> <ul> <li>session - events for changes in session state and mobility start/stop/pause</li> <li>node - events for node movements and icon changes</li> <li>link - events for link configuration changes and wireless link add/delete</li> <li>config - configuration events when legacy gui joins a session</li> <li>alert - alert events</li> <li>file - file events when the legacy gui joins a session</li> </ul> <pre><code>from core.emulator.data import EventData, AlertData, LinkData, NodeData\n\n\ndef event_listener(event):\n    print(event)\n\n\n# add an event listener to event type you want to listen to\n# each handler will receive an object unique to that type\nsession.broadcast_manager.add_handler(NodeData, event_listener)\nsession.broadcast_manager.add_handler(LinkData, event_listener)\nsession.broadcast_manager.add_handler(EventData, event_listener)\nsession.broadcast_manager.add_handler(AlertData, event_listener)\n</code></pre>"},{"location":"python.html#configuring-links","title":"Configuring Links","text":"<p>Links can be configured at the time of creation or during runtime.</p> <p>Currently supported configuration options:</p> <ul> <li>bandwidth (bps)</li> <li>delay (us)</li> <li>dup (%)</li> <li>jitter (us)</li> <li>loss (%)</li> </ul> <pre><code>from core.emulator.data import LinkOptions\n\n# configuring when creating a link\noptions = LinkOptions(\n    bandwidth=54_000_000,\n    delay=5000,\n    dup=5,\n    loss=5.5,\n    jitter=0,\n)\nsession.add_link(n1_id, n2_id, iface1_data, iface2_data, options)\n\n# configuring during runtime\nsession.update_link(n1_id, n2_id, iface1_id, iface2_id, options)\n</code></pre>"},{"location":"python.html#peer-to-peer-example","title":"Peer to Peer Example","text":"<pre><code># required imports\nfrom core.emulator.coreemu import CoreEmu\nfrom core.emulator.data import IpPrefixes\nfrom core.emulator.enumerations import EventTypes\nfrom core.nodes.base import CoreNode, Position\n\n# ip nerator for example\nip_prefixes = IpPrefixes(ip4_prefix=\"10.0.0.0/24\")\n\n# create emulator instance for creating sessions and utility methods\ncoreemu = CoreEmu()\nsession = coreemu.create_session()\n\n# must be in configuration state for nodes to start, when using \"node_add\" below\nsession.set_state(EventTypes.CONFIGURATION_STATE)\n\n# create nodes\nposition = Position(x=100, y=100)\nn1 = session.add_node(CoreNode, position=position)\nposition = Position(x=300, y=100)\nn2 = session.add_node(CoreNode, position=position)\n\n# link nodes together\niface1 = ip_prefixes.create_iface(n1)\niface2 = ip_prefixes.create_iface(n2)\nsession.add_link(n1.id, n2.id, iface1, iface2)\n\n# start session\nsession.instantiate()\n\n# do whatever you like here\ninput(\"press enter to shutdown\")\n\n# stop session\nsession.shutdown()\n</code></pre>"},{"location":"python.html#switchhub-example","title":"Switch/Hub Example","text":"<pre><code># required imports\nfrom core.emulator.coreemu import CoreEmu\nfrom core.emulator.data import IpPrefixes\nfrom core.emulator.enumerations import EventTypes\nfrom core.nodes.base import CoreNode, Position\nfrom core.nodes.network import SwitchNode\n\n# ip nerator for example\nip_prefixes = IpPrefixes(ip4_prefix=\"10.0.0.0/24\")\n\n# create emulator instance for creating sessions and utility methods\ncoreemu = CoreEmu()\nsession = coreemu.create_session()\n\n# must be in configuration state for nodes to start, when using \"node_add\" below\nsession.set_state(EventTypes.CONFIGURATION_STATE)\n\n# create switch\nposition = Position(x=200, y=200)\nswitch = session.add_node(SwitchNode, position=position)\n\n# create nodes\nposition = Position(x=100, y=100)\nn1 = session.add_node(CoreNode, position=position)\nposition = Position(x=300, y=100)\nn2 = session.add_node(CoreNode, position=position)\n\n# link nodes to switch\niface1 = ip_prefixes.create_iface(n1)\nsession.add_link(n1.id, switch.id, iface1)\niface1 = ip_prefixes.create_iface(n2)\nsession.add_link(n2.id, switch.id, iface1)\n\n# start session\nsession.instantiate()\n\n# do whatever you like here\ninput(\"press enter to shutdown\")\n\n# stop session\nsession.shutdown()\n</code></pre>"},{"location":"python.html#wlan-example","title":"WLAN Example","text":"<pre><code># required imports\nfrom core.emulator.coreemu import CoreEmu\nfrom core.emulator.data import IpPrefixes\nfrom core.emulator.enumerations import EventTypes\nfrom core.location.mobility import BasicRangeModel\nfrom core.nodes.base import CoreNode, Position\nfrom core.nodes.network import WlanNode\n\n# ip nerator for example\nip_prefixes = IpPrefixes(ip4_prefix=\"10.0.0.0/24\")\n\n# create emulator instance for creating sessions and utility methods\ncoreemu = CoreEmu()\nsession = coreemu.create_session()\n\n# must be in configuration state for nodes to start, when using \"node_add\" below\nsession.set_state(EventTypes.CONFIGURATION_STATE)\n\n# create wlan\nposition = Position(x=200, y=200)\nwlan = session.add_node(WlanNode, position=position)\n\n# create nodes\noptions = CoreNode.create_options()\noptions.model = \"mdr\"\nposition = Position(x=100, y=100)\nn1 = session.add_node(CoreNode, position=position, options=options)\nposition = Position(x=300, y=100)\nn2 = session.add_node(CoreNode, position=position, options=options)\n\n# configuring wlan\nsession.mobility.set_model_config(wlan.id, BasicRangeModel.name, {\n    \"range\": \"280\",\n    \"bandwidth\": \"55000000\",\n    \"delay\": \"6000\",\n    \"jitter\": \"5\",\n    \"error\": \"5\",\n})\n\n# link nodes to wlan\niface1 = ip_prefixes.create_iface(n1)\nsession.add_link(n1.id, wlan.id, iface1)\niface1 = ip_prefixes.create_iface(n2)\nsession.add_link(n2.id, wlan.id, iface1)\n\n# start session\nsession.instantiate()\n\n# do whatever you like here\ninput(\"press enter to shutdown\")\n\n# stop session\nsession.shutdown()\n</code></pre>"},{"location":"python.html#emane-example","title":"EMANE Example","text":"<p>For EMANE you can import and use one of the existing models and use its name for configuration.</p> <p>Current models:</p> <ul> <li>core.emane.ieee80211abg.EmaneIeee80211abgModel</li> <li>core.emane.rfpipe.EmaneRfPipeModel</li> <li>core.emane.tdma.EmaneTdmaModel</li> <li>core.emane.bypass.EmaneBypassModel</li> </ul> <p>Their configurations options are driven dynamically from parsed EMANE manifest files from the installed version of EMANE.</p> <p>Options and their purpose can be found at the EMANE Wiki.</p> <p>If configuring EMANE global settings or model mac/phy specific settings, any value not provided will use the defaults. When no configuration is used, the defaults are used.</p> <pre><code># required imports\nfrom core.emane.models.ieee80211abg import EmaneIeee80211abgModel\nfrom core.emane.nodes import EmaneNet\nfrom core.emulator.coreemu import CoreEmu\nfrom core.emulator.data import IpPrefixes\nfrom core.emulator.enumerations import EventTypes\nfrom core.nodes.base import CoreNode, Position\n\n# ip nerator for example\nip_prefixes = IpPrefixes(ip4_prefix=\"10.0.0.0/24\")\n\n# create emulator instance for creating sessions and utility methods\ncoreemu = CoreEmu()\nsession = coreemu.create_session()\n\n# location information is required to be set for emane\nsession.location.setrefgeo(47.57917, -122.13232, 2.0)\nsession.location.refscale = 150.0\n\n# must be in configuration state for nodes to start, when using \"node_add\" below\nsession.set_state(EventTypes.CONFIGURATION_STATE)\n\n# create emane\noptions = EmaneNet.create_options()\noptions.emane_model = EmaneIeee80211abgModel.name\nposition = Position(x=200, y=200)\nemane = session.add_node(EmaneNet, position=position, options=options)\n\n# create nodes\noptions = CoreNode.create_options()\noptions.model = \"mdr\"\nposition = Position(x=100, y=100)\nn1 = session.add_node(CoreNode, position=position, options=options)\nposition = Position(x=300, y=100)\nn2 = session.add_node(CoreNode, position=position, options=options)\n\n# configure emane model using a dict, which currently support values as strings\nsession.emane.set_config(emane.id, EmaneIeee80211abgModel.name, {\n    \"eventservicettl\": \"2\",\n    \"unicastrate\": \"3\",\n})\n\n# link nodes to emane\niface1 = ip_prefixes.create_iface(n1)\nsession.add_link(n1.id, emane.id, iface1)\niface1 = ip_prefixes.create_iface(n2)\nsession.add_link(n2.id, emane.id, iface1)\n\n# start session\nsession.instantiate()\n\n# do whatever you like here\ninput(\"press enter to shutdown\")\n\n# stop session\nsession.shutdown()\n</code></pre> <p>EMANE Model Configuration:</p> <pre><code>from core import utils\n\n# standardized way to retrieve an appropriate config id\n# iface id can be omitted, to allow a general configuration for a model, per node\nconfig_id = utils.iface_config_id(node.id, iface_id)\n# set emane configuration for the config id\nsession.emane.set_config(config_id, EmaneIeee80211abgModel.name, {\n    \"unicastrate\": \"3\",\n})\n</code></pre>"},{"location":"python.html#configuring-a-service","title":"Configuring a Service","text":"<p>Services help generate and run bash scripts on nodes for a given purpose.</p> <p>Configuring the templates of a service results in a specific hard coded script being generated, instead of the default scripts, that may leverage dynamic generation.</p> <p>The following features can be configured for a service:</p> <ul> <li>files - files that will be generated</li> <li>directories - directories that will be mounted unique to the node</li> <li>startup - commands to run start a service</li> <li>validate - commands to run to validate a service</li> <li>shutdown - commands to run to stop a service</li> </ul> <p>Editing service properties: <pre><code># configure a service, for a node, for a given session\nnode = session.get_node(node_id, CoreNode)\nservice = node.services[service_name]\nservice.files = [\"file1.sh\", \"file2.sh\"]\nservice.directories = [\"/etc/node\"]\nservice.startup = [\"bash file1.sh\"]\nservice.validate = []\nservice.shutdown = []\n</code></pre></p> <p>When editing a service file, it must be the name of <code>file</code> that the service will generate.</p> <p>Editing a service file: <pre><code># to edit the contents of a generated file you can specify\n# the service, the file name, and its contents\nnode = session.get_node(node_id, CoreNode)\nservice = node.services[service_name]\nservice.set_template(file_name, \"echo hello\")\n</code></pre></p>"},{"location":"python.html#file-examples","title":"File Examples","text":"<p>File versions of the network examples can be found here.</p>"},{"location":"python.html#executing-scripts-from-gui","title":"Executing Scripts from GUI","text":"<p>To execute a python script from a GUI you need have the following.</p> <p>The builtin name check here to know it is being executed from the GUI, this can be avoided if your script does not use a name check.</p> <pre><code>if __name__ in [\"__main__\", \"__builtin__\"]:\n    main()\n</code></pre> <p>A script can add sessions to the core-daemon. A global coreemu variable is exposed to the script pointing to the CoreEmu object.</p> <p>The example below has a fallback to a new CoreEmu object, in the case you would like to run the script standalone, outside of the core-daemon.</p> <pre><code>coreemu = globals().get(\"coreemu\") or CoreEmu()\nsession = coreemu.create_session()\n</code></pre>"},{"location":"services.html","title":"Services","text":""},{"location":"services.html#overview","title":"Overview","text":"<p>CORE uses the concept of services to specify what processes or scripts to run on a node when it is started. Ultimately, providing a convenience for creating reusable dynamic scripts to run on nodes, for carrying out specific tasks.</p> <p>Services leverage a templating engine, for robust service file creation. They also have the power of configuration key/value pairs, that can be defined and displayed within the GUI, to help further configure a service, as needed.</p> <p>This boils down to the following functions:</p> <ul> <li>generating files the service will use, either directly for commands or for configuration</li> <li>command(s) for starting a service</li> <li>command(s) for validating a service</li> <li>command(s) for stopping a service</li> </ul> <p>Most CORE nodes will have a default set of services to run, associated with them. You can however customize the set of services a node will use. Or even further define a new node type within the GUI, with a set of services, that will allow quickly dragging and dropping that node type during creation.</p>"},{"location":"services.html#available-services","title":"Available Services","text":"Service Group Services BIRD BGP, OSPF, RADV, RIP, Static EMANE Transport Service FRR BABEL, BGP, OSPFv2, OSPFv3, PIMD, RIP, RIPNG, Zebra NRL arouted, MGEN Sink, MGEN Actor, NHDP, OLSR, OLSRORG, OLSRv2, SMF Quagga BABEL, BGP, OSPFv2, OSPFv3, OSPFv3 MDR, RIP, RIPNG, XPIMD, Zebra SDN OVS, RYU Security Firewall, IPsec, NAT, VPN Client, VPN Server Utility ATD, Routing Utils, DHCP, FTP, IP Forward, PCAP, RADVD, SSF, UCARP XORP BGP, OLSR, OSPFv2, OSPFv3, PIMSM4, PIMSM6, RIP, RIPNG, Router Manager"},{"location":"services.html#node-types-and-default-services","title":"Node Types and Default Services","text":"<p>Here are the default node types and their services:</p> Node Type Services router zebra, OSFPv2, OSPFv3, and IPForward services for IGP link-state routing. PC DefaultRoute service for having a default route when connected directly to a router. mdr zebra, OSPFv3MDR, and IPForward services for wireless-optimized MANET Designated Router routing. prouter a physical router, having the same default services as the router node type; for incorporating Linux testbed machines into an emulation. <p>Configuration files can be automatically generated by each service. For example, CORE automatically generates routing protocol configuration for the router nodes in order to simplify the creation of virtual networks.</p> <p>To change the services associated with a node, right-click a node a choose Services... from the menu button. Services are enabled or disabled by selecting through the service groups and enabling the checkboxes on services. Select a selected service and click the Configure button to further configure a given service.</p> <p>To change the default services associated with a node type, use the Custom Nodes option under the Edit menu option. Here you can define new node types, with a custom icon, and a custom set of services to start on nodes of this type. This node type will be added to the container node options on the left toolbar, allowing for easy drag and drop creation for nodes of this type.</p> <p>The node types are saved in the GUI config file ~/.coregui/config.yaml. Keep this in mind when changing the default services for existing node types; it may be better to simply create a new node type. It is recommended that you do not change the default built-in node types.</p>"},{"location":"services.html#new-services","title":"New Services","text":"<p>Services can save time required to configure nodes, especially if a number of nodes require similar configuration procedures. New services can be introduced to automate tasks.</p>"},{"location":"services.html#creating-new-services","title":"Creating New Services","text":"<p>Note</p> <p>The directory base name used in custom_services_dir below should be unique and should not correspond to any existing Python module name. For example, don't use the name subprocess or services.</p> <ol> <li> <p>Modify the example service shown below    to do what you want. It could generate config/script files, mount per-node    directories, start processes/scripts, etc. Your file can define one or more    classes to be imported. You can create multiple Python files that will be imported.</p> </li> <li> <p>Put these files in a directory such as ~/.coregui/custom_services.</p> </li> <li> <p>Set the custom_services_dir = ~/.coregui/custom_services entry to the    /opt/core/etc/core.conf file.</p> </li> <li> <p>Restart the CORE daemon (core-daemon). Any import errors (Python syntax)    should be displayed in the terminal (or service log, like journalctl).</p> </li> <li> <p>Start using your custom service on your nodes. You can create a new node    type that uses your service, or change the default services for an existing    node type, or change individual nodes.</p> </li> </ol>"},{"location":"services.html#example-custom-service","title":"Example Custom Service","text":"<p>Below is the skeleton for a custom service with some documentation. Most people would likely only setup the required class variables (name/group). Then define the files to generate and implement the get_text_template function to dynamically create the files wanted. Finally, the startup commands would be supplied, which typically tend to be running the shell files generated.</p> <p>This is a very simple service using the bare minimum needed. <pre><code>from core.services.base import CoreService\n\nclass ExampleService(CoreService):\n    name: str = \"Node Name\"\n    group: str = \"ExampleGroup\"\n    files: list[str] = [\"node_name.sh\"]\n    startup: list[str] = [f\"bash {files[0]}\"]\n\n    def get_text_template(self, name: str) -&gt; str:\n        return \"\"\"\n        echo '${node.name}' &gt; node_name.log\n        \"\"\"\n</code></pre></p> <p>This fleshes out all the fields and helps document their purpose. <pre><code>from core.config import ConfigString, ConfigBool, Configuration\nfrom core.services.base import CoreService, ShadowDir, ServiceMode\n\n\n# class that subclasses CoreService\nclass ExampleService(CoreService):\n    # unique name for your service within CORE\n    name: str = \"Example\"\n    # the group your service is associated with, used for display in GUI\n    group: str = \"ExampleGroup\"\n    # directories that the service should shadow mount, hiding the system directory\n    directories: list[str] = [\"/usr/local/core\"]\n    # files that this service should generate, defaults to nodes home directory\n    # or can provide an absolute path to a mounted directory\n    files: list[str] = [\"example-start.sh\"]\n    # executables that should exist on path, that this service depends on\n    executables: list[str] = []\n    # other services that this service depends on, defines service start order\n    dependencies: list[str] = []\n    # commands to run to start this service\n    startup: list[str] = []\n    # commands to run to validate this service\n    validate: list[str] = []\n    # commands to run to stop this service\n    shutdown: list[str] = []\n    # validation mode BLOCKING, NON_BLOCKING, and TIMER\n    validation_mode: ServiceMode = ServiceMode.BLOCKING\n    # configurable values that this service can use, for file generation\n    default_configs: list[Configuration] = [\n        ConfigString(id=\"value1\", label=\"Text\"),\n        ConfigBool(id=\"value2\", label=\"Boolean\"),\n        ConfigString(id=\"value3\", label=\"Multiple Choice\",\n                     options=[\"value1\", \"value2\", \"value3\"]),\n    ]\n    # sets of values to set for the configuration defined above, can be used to\n    # provide convenient sets of values to typically use\n    modes: dict[str, dict[str, str]] = {\n        \"mode1\": {\"value1\": \"value1\", \"value2\": \"0\", \"value3\": \"value2\"},\n        \"mode2\": {\"value1\": \"value2\", \"value2\": \"1\", \"value3\": \"value3\"},\n        \"mode3\": {\"value1\": \"value3\", \"value2\": \"0\", \"value3\": \"value1\"},\n    }\n    # defines directories that this service can help shadow within a node\n    shadow_directories: list[ShadowDir] = []\n\n    def get_text_template(self, name: str) -&gt; str:\n        \"\"\"\n        This function is used to return a string template that will be rendered\n        by the templating engine. Available variables will be node and any other\n        key/value pairs returned by the \"data()\" function.\n\n        :param name: name of file to get template for\n        :return: string template\n        \"\"\"\n        return \"\"\"\n        # sample script 1\n        # node id(${node.id}) name(${node.name})\n        # config: ${config}\n        echo hello\n        \"\"\"\n</code></pre></p>"},{"location":"services.html#validation-mode","title":"Validation Mode","text":"<p>Validation modes are used to determine if a service has started up successfully.</p> <ul> <li><code>BLOCKING</code> - startup commands are expected to run til completion and return 0 exit code</li> <li><code>NON_BLOCKING</code> - startup commands are ran, but do not wait for completion</li> <li><code>TIMER</code> - startup commands are ran, and an arbitrary amount of time is waited to consider started</li> </ul>"},{"location":"services.html#shadow-directories","title":"Shadow Directories","text":"<p>Shadow directories provide a convenience for copying a directory and the files within it to a nodes home directory, to allow a unique set of per node files.</p> <ul> <li><code>ShadowDir(path=\"/user/local/core\")</code> - copies files at the given location into the node</li> <li><code>ShadowDir(path=\"/user/local/core\", src=\"/opt/core\")</code> - copies files to the given location,   but sourced from the provided location</li> <li><code>ShadowDir(path=\"/user/local/core\", templates=True)</code> - copies files and treats them as   templates for generation</li> <li><code>ShadowDir(path=\"/user/local/core\", has_node_paths=True)</code> - copies files from the given   location, and looks for unique node names directories within it, using a directory named   default, when not preset</li> </ul>"},{"location":"emane/antenna.html","title":"EMANE Antenna Profiles","text":""},{"location":"emane/antenna.html#overview","title":"Overview","text":"<p>Introduction to using the EMANE antenna profile in CORE, based on the example EMANE Demo linked below.</p> <p>EMANE Demo 6 for more specifics.</p>"},{"location":"emane/antenna.html#demo-setup","title":"Demo Setup","text":"<p>We will need to create some files in advance of starting this session.</p> <p>Create directory to place antenna profile files.</p> <pre><code>mkdir /tmp/emane\n</code></pre> <p>Create <code>/tmp/emane/antennaprofile.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE profiles SYSTEM \"file:///usr/share/emane/dtd/antennaprofile.dtd\"&gt;\n&lt;profiles&gt;\n    &lt;profile id=\"1\"\n             antennapatternuri=\"/tmp/emane/antenna30dsector.xml\"\n             blockagepatternuri=\"/tmp/emane/blockageaft.xml\"&gt;\n        &lt;placement north=\"0\" east=\"0\" up=\"0\"/&gt;\n    &lt;/profile&gt;\n    &lt;profile id=\"2\"\n             antennapatternuri=\"/tmp/emane/antenna30dsector.xml\"&gt;\n        &lt;placement north=\"0\" east=\"0\" up=\"0\"/&gt;\n    &lt;/profile&gt;\n&lt;/profiles&gt;\n</code></pre> <p>Create <code>/tmp/emane/antenna30dsector.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE antennaprofile SYSTEM \"file:///usr/share/emane/dtd/antennaprofile.dtd\"&gt;\n\n&lt;!-- 30degree sector antenna pattern with main beam at +6dB and gain decreasing by 3dB every 5 degrees in elevation or bearing.--&gt;\n&lt;antennaprofile&gt;\n    &lt;antennapattern&gt;\n        &lt;elevation min='-90' max='-16'&gt;\n            &lt;bearing min='0' max='359'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-15' max='-11'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-10' max='-6'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-5' max='-1'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='6'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='0' max='5'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='6'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='6' max='10'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='3'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='11' max='15'&gt;\n            &lt;bearing min='0' max='5'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='6' max='10'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='11' max='15'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='16' max='344'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='345' max='349'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='350' max='354'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='355' max='359'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='16' max='90'&gt;\n            &lt;bearing min='0' max='359'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n    &lt;/antennapattern&gt;\n&lt;/antennaprofile&gt;\n</code></pre> <p>Create <code>/tmp/emane/blockageaft.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE antennaprofile SYSTEM \"file:///usr/share/emane/dtd/antennaprofile.dtd\"&gt;\n\n&lt;!-- blockage pattern: 1) entire aft in bearing (90 to 270) blocked 2) elevation below -10 blocked, 3) elevation from -10 to -1 is at -10dB to -1 dB 3) elevation from 0 to 90 no blockage--&gt;\n&lt;antennaprofile&gt;\n    &lt;blockagepattern&gt;\n        &lt;elevation min='-90' max='-11'&gt;\n            &lt;bearing min='0' max='359'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-10' max='-10'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-10'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-10'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-9' max='-9'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-9'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-9'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-8' max='-8'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-8'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-8'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-7' max='-7'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-7'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-7'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-6' max='-6'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-6'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-5' max='-5'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-5'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-5'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-4' max='-4'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-4'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-4'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-3' max='-3'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-3'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-2' max='-2'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-2'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-2'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='-1' max='-1'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='-1'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='-1'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n        &lt;elevation min='0' max='90'&gt;\n            &lt;bearing min='0' max='89'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='90' max='270'&gt;\n                &lt;gain value='-200'/&gt;\n            &lt;/bearing&gt;\n            &lt;bearing min='271' max='359'&gt;\n                &lt;gain value='0'/&gt;\n            &lt;/bearing&gt;\n        &lt;/elevation&gt;\n    &lt;/blockagepattern&gt;\n&lt;/antennaprofile&gt;\n</code></pre>"},{"location":"emane/antenna.html#run-demo","title":"Run Demo","text":"<ol> <li>Select <code>Open...</code> within the GUI</li> <li>Load <code>emane-demo-antenna.xml</code></li> <li>Click </li> <li>After startup completes, double click n1 to bring up the nodes terminal</li> </ol>"},{"location":"emane/antenna.html#example-demo","title":"Example Demo","text":"<p>This demo will cover running an EMANE event service to feed in antenna, location, and pathloss events to demonstrate how antenna profiles can be used.</p>"},{"location":"emane/antenna.html#emane-event-dump","title":"EMANE Event Dump","text":"<p>On n1 lets dump EMANE events, so when we later run the EMANE event service you can monitor when and what is sent.</p> <pre><code>root@n1:/tmp/pycore.44917/n1.conf# emaneevent-dump -i ctrl0\n</code></pre>"},{"location":"emane/antenna.html#send-emane-events","title":"Send EMANE Events","text":"<p>On the host machine create the following to send EMANE events.</p> <p>Warning</p> <p>Make sure to set the <code>eventservicedevice</code> to the proper control network value</p> <p>Create <code>eventservice.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventservice SYSTEM \"file:///usr/share/emane/dtd/eventservice.dtd\"&gt;\n&lt;eventservice&gt;\n    &lt;param name=\"eventservicegroup\" value=\"224.1.2.8:45703\"/&gt;\n    &lt;param name=\"eventservicedevice\" value=\"b.9001.da\"/&gt;\n    &lt;generator definition=\"eelgenerator.xml\"/&gt;\n&lt;/eventservice&gt;\n</code></pre> <p>Create <code>eelgenerator.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventgenerator SYSTEM \"file:///usr/share/emane/dtd/eventgenerator.dtd\"&gt;\n&lt;eventgenerator library=\"eelgenerator\"&gt;\n    &lt;param name=\"inputfile\" value=\"scenario.eel\"/&gt;\n    &lt;paramlist name=\"loader\"&gt;\n        &lt;item value=\"commeffect:eelloadercommeffect:delta\"/&gt;\n        &lt;item value=\"location,velocity,orientation:eelloaderlocation:delta\"/&gt;\n        &lt;item value=\"pathloss:eelloaderpathloss:delta\"/&gt;\n        &lt;item value=\"antennaprofile:eelloaderantennaprofile:delta\"/&gt;\n    &lt;/paramlist&gt;\n&lt;/eventgenerator&gt;\n</code></pre> <p>Create <code>scenario.eel</code> with the following contents.</p> <pre><code>0.0 nem:1 antennaprofile 1,0.0,0.0\n0.0 nem:4 antennaprofile 2,0.0,0.0\n#\n0.0 nem:1  pathloss nem:2,60  nem:3,60   nem:4,60\n0.0 nem:2  pathloss nem:3,60  nem:4,60\n0.0 nem:3  pathloss nem:4,60\n#\n0.0 nem:1  location gps 40.025495,-74.315441,3.0\n0.0 nem:2  location gps 40.025495,-74.312501,3.0\n0.0 nem:3  location gps 40.023235,-74.315441,3.0\n0.0 nem:4  location gps 40.023235,-74.312501,3.0\n0.0 nem:4  velocity 180.0,0.0,10.0\n#\n30.0 nem:1 velocity 20.0,0.0,10.0\n30.0 nem:1 orientation 0.0,0.0,10.0\n30.0 nem:1 antennaprofile 1,60.0,0.0\n30.0 nem:4 velocity 270.0,0.0,10.0\n#\n60.0 nem:1 antennaprofile 1,105.0,0.0\n60.0 nem:4 antennaprofile 2,45.0,0.0\n#\n90.0 nem:1 velocity 90.0,0.0,10.0\n90.0 nem:1 orientation 0.0,0.0,0.0\n90.0 nem:1 antennaprofile 1,45.0,0.0\n</code></pre> <p>Run the EMANE event service, monitor what is output on n1 for events dumped and see the link changes within the CORE GUI.</p> <pre><code>emaneeventservice -l 3 eventservice.xml\n</code></pre>"},{"location":"emane/antenna.html#stages","title":"Stages","text":"<p>The events sent will trigger 4 different states.</p> <ul> <li>State 1<ul> <li>n2 and n3 see each other</li> <li>n4 and n3 are pointing away</li> </ul> </li> <li>State 2<ul> <li>n2 and n3 see each other</li> <li>n1 and n2 see each other</li> <li>n4 and n3 see each other</li> </ul> </li> <li>State 3<ul> <li>n2 and n3 see each other</li> <li>n4 and n3 are pointing at each other but blocked</li> </ul> </li> <li>State 4<ul> <li>n2 and n3 see each other</li> <li>n4 and n3 see each other</li> </ul> </li> </ul>"},{"location":"emane/eel.html","title":"EMANE Emulation Event Log (EEL) Generator","text":""},{"location":"emane/eel.html#overview","title":"Overview","text":"<p>Introduction to using the EMANE event service and eel files to provide events.</p> <p>EMANE Demo 1 for more specifics.</p>"},{"location":"emane/eel.html#run-demo","title":"Run Demo","text":"<ol> <li>Select <code>Open...</code> within the GUI</li> <li>Load <code>emane-demo-eel.xml</code></li> <li>Click </li> <li>After startup completes, double click n1 to bring up the nodes terminal</li> </ol>"},{"location":"emane/eel.html#example-demo","title":"Example Demo","text":"<p>This demo will go over defining an EMANE event service and eel file to drive an emane event service.</p>"},{"location":"emane/eel.html#viewing-events","title":"Viewing Events","text":"<p>On n1 we will use the EMANE event dump utility to listen to events.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# emaneevent-dump -i ctrl0\n</code></pre>"},{"location":"emane/eel.html#sending-events","title":"Sending Events","text":"<p>On the host machine we will create the following files and start the EMANE event service targeting the control network.</p> <p>Warning</p> <p>Make sure to set the <code>eventservicedevice</code> to the proper control network value</p> <p>Create <code>eventservice.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventservice SYSTEM \"file:///usr/share/emane/dtd/eventservice.dtd\"&gt;\n&lt;eventservice&gt;\n    &lt;param name=\"eventservicegroup\" value=\"224.1.2.8:45703\"/&gt;\n    &lt;param name=\"eventservicedevice\" value=\"b.9001.f\"/&gt;\n    &lt;generator definition=\"eelgenerator.xml\"/&gt;\n&lt;/eventservice&gt;\n</code></pre> <p>Next we will create the <code>eelgenerator.xml</code> file. The EEL Generator is actually a plugin that loads sentence parsing plugins. The sentence parsing plugins know how to convert certain sentences, in this case commeffect, location, velocity, orientation, pathloss and antennaprofile sentences, into their corresponding emane event equivalents.</p> <ul> <li>commeffect:eelloadercommeffect:delta</li> <li>location,velocity,orientation:eelloaderlocation:delta</li> <li>pathloss:eelloaderpathloss:delta</li> <li>antennaprofile:eelloaderantennaprofile:delta</li> </ul> <p>These configuration items tell the EEL Generator which sentences to map to which plugin and whether to issue delta or full updates.</p> <p>Create <code>eelgenerator.xml</code> with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventgenerator SYSTEM \"file:///usr/share/emane/dtd/eventgenerator.dtd\"&gt;\n&lt;eventgenerator library=\"eelgenerator\"&gt;\n    &lt;param name=\"inputfile\" value=\"scenario.eel\"/&gt;\n    &lt;paramlist name=\"loader\"&gt;\n        &lt;item value=\"commeffect:eelloadercommeffect:delta\"/&gt;\n        &lt;item value=\"location,velocity,orientation:eelloaderlocation:delta\"/&gt;\n        &lt;item value=\"pathloss:eelloaderpathloss:delta\"/&gt;\n        &lt;item value=\"antennaprofile:eelloaderantennaprofile:delta\"/&gt;\n    &lt;/paramlist&gt;\n&lt;/eventgenerator&gt;\n</code></pre> <p>Finally, create <code>scenario.eel</code> with the following contents.</p> <pre><code>0.0  nem:1 pathloss nem:2,90.0\n0.0  nem:2 pathloss nem:1,90.0\n0.0  nem:1 location gps 40.031075,-74.523518,3.000000\n0.0  nem:2 location gps 40.031165,-74.523412,3.000000\n</code></pre> <p>Start the EMANE event service using the files created above.</p> <pre><code>emaneeventservice eventservice.xml -l 3\n</code></pre>"},{"location":"emane/eel.html#sent-events","title":"Sent Events","text":"<p>If we go back to look at our original terminal we will see the events logged out to the terminal.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# emaneevent-dump -i ctrl0\n[1601858142.917224] nem: 0 event: 100 len: 66 seq: 1 [Location]\n UUID: 0af267be-17d3-4103-9f76-6f697e13bcec\n   (1, {'latitude': 40.031075, 'altitude': 3.0, 'longitude': -74.823518})\n   (2, {'latitude': 40.031165, 'altitude': 3.0, 'longitude': -74.523412})\n[1601858142.917466] nem: 1 event: 101 len: 14 seq: 2 [Pathloss]\n UUID: 0af267be-17d3-4103-9f76-6f697e13bcec\n   (2, {'forward': 90.0, 'reverse': 90.0})\n[1601858142.917889] nem: 2 event: 101 len: 14 seq: 3 [Pathloss]\n UUID: 0af267be-17d3-4103-9f76-6f697e13bcec\n   (1, {'forward': 90.0, 'reverse': 90.0})\n</code></pre>"},{"location":"emane/files.html","title":"EMANE XML Files","text":""},{"location":"emane/files.html#overview","title":"Overview","text":"<p>Introduction to the XML files generated by CORE used to drive EMANE for a given node.</p> <p>EMANE Demo 0 may provide more helpful details.</p>"},{"location":"emane/files.html#run-demo","title":"Run Demo","text":"<ol> <li>Select <code>Open...</code> within the GUI</li> <li>Load <code>emane-demo-files.xml</code></li> <li>Click </li> <li>After startup completes, double click n1 to bring up the nodes terminal</li> </ol>"},{"location":"emane/files.html#example-demo","title":"Example Demo","text":"<p>We will take a look at the files generated in the example demo provided. In this case we are running the RF Pipe model.</p>"},{"location":"emane/files.html#generated-files","title":"Generated Files","text":"Name Description \\-platform.xml configuration file for the emulator instances \\-nem.xml configuration for creating a NEM \\-mac.xml configuration for defining a NEMs MAC layer \\-phy.xml configuration for defining a NEMs PHY layer \\-trans-virtual.xml configuration when a virtual transport is being used \\-trans.xml configuration when a raw transport is being used"},{"location":"emane/files.html#listing-file","title":"Listing File","text":"<p>Below are the files within n1 after starting the demo session.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# ls\neth0-mac.xml  eth0-trans-virtual.xml  n1-platform.xml       var.log\neth0-nem.xml  ipforward.sh            quaggaboot.sh         var.run\neth0-phy.xml  n1-emane.log            usr.local.etc.quagga  var.run.quagga\n</code></pre>"},{"location":"emane/files.html#platform-xml","title":"Platform XML","text":"<p>The root configuration file used to run EMANE for a node is the platform xml file. In this demo we are looking at <code>n1-platform.xml</code>.</p> <ul> <li>lists all configuration values set for the platform</li> <li>The unique nem id given for each interface that EMANE will create for this node</li> <li>The path to the file(s) used for definition for a given nem</li> </ul> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# cat n1-platform.xml\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;!DOCTYPE platform SYSTEM \"file:///usr/share/emane/dtd/platform.dtd\"&gt;\n&lt;platform&gt;\n  &lt;param name=\"antennaprofilemanifesturi\" value=\"\"/&gt;\n  &lt;param name=\"controlportendpoint\" value=\"0.0.0.0:47000\"/&gt;\n  &lt;param name=\"eventservicedevice\" value=\"ctrl0\"/&gt;\n  &lt;param name=\"eventservicegroup\" value=\"224.1.2.8:45703\"/&gt;\n  &lt;param name=\"eventservicettl\" value=\"1\"/&gt;\n  &lt;param name=\"otamanagerchannelenable\" value=\"1\"/&gt;\n  &lt;param name=\"otamanagerdevice\" value=\"ctrl0\"/&gt;\n  &lt;param name=\"otamanagergroup\" value=\"224.1.2.8:45702\"/&gt;\n  &lt;param name=\"otamanagerloopback\" value=\"0\"/&gt;\n  &lt;param name=\"otamanagermtu\" value=\"0\"/&gt;\n  &lt;param name=\"otamanagerpartcheckthreshold\" value=\"2\"/&gt;\n  &lt;param name=\"otamanagerparttimeoutthreshold\" value=\"5\"/&gt;\n  &lt;param name=\"otamanagerttl\" value=\"1\"/&gt;\n  &lt;param name=\"stats.event.maxeventcountrows\" value=\"0\"/&gt;\n  &lt;param name=\"stats.ota.maxeventcountrows\" value=\"0\"/&gt;\n  &lt;param name=\"stats.ota.maxpacketcountrows\" value=\"0\"/&gt;\n  &lt;nem id=\"1\" name=\"tap1.0.f\" definition=\"eth0-nem.xml\"&gt;\n    &lt;transport definition=\"eth0-trans-virtual.xml\"&gt;\n      &lt;param name=\"device\" value=\"eth0\"/&gt;\n    &lt;/transport&gt;\n  &lt;/nem&gt;\n&lt;/platform&gt;\n</code></pre>"},{"location":"emane/files.html#nem-xml","title":"NEM XML","text":"<p>The nem definition will contain reference to the transport, mac, and phy xml definitions being used for a given nem.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# cat eth0-nem.xml\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;!DOCTYPE nem SYSTEM \"file:///usr/share/emane/dtd/nem.dtd\"&gt;\n&lt;nem name=\"emane_rfpipe NEM\"&gt;\n  &lt;transport definition=\"eth0-trans-virtual.xml\"/&gt;\n  &lt;mac definition=\"eth0-mac.xml\"/&gt;\n  &lt;phy definition=\"eth0-phy.xml\"/&gt;\n&lt;/nem&gt;\n</code></pre>"},{"location":"emane/files.html#mac-xml","title":"MAC XML","text":"<p>MAC layer configuration settings would be found in this file. CORE will write out all values, even if the value is a default value.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# cat eth0-mac.xml\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;!DOCTYPE mac SYSTEM \"file:///usr/share/emane/dtd/mac.dtd\"&gt;\n&lt;mac name=\"emane_rfpipe MAC\" library=\"rfpipemaclayer\"&gt;\n  &lt;param name=\"datarate\" value=\"1000000\"/&gt;\n  &lt;param name=\"delay\" value=\"0.000000\"/&gt;\n  &lt;param name=\"enablepromiscuousmode\" value=\"0\"/&gt;\n  &lt;param name=\"flowcontrolenable\" value=\"0\"/&gt;\n  &lt;param name=\"flowcontroltokens\" value=\"10\"/&gt;\n  &lt;param name=\"jitter\" value=\"0.000000\"/&gt;\n  &lt;param name=\"neighbormetricdeletetime\" value=\"60.000000\"/&gt;\n  &lt;param name=\"pcrcurveuri\" value=\"/usr/share/emane/xml/models/mac/rfpipe/rfpipepcr.xml\"/&gt;\n  &lt;param name=\"radiometricenable\" value=\"0\"/&gt;\n  &lt;param name=\"radiometricreportinterval\" value=\"1.000000\"/&gt;\n&lt;/mac&gt;\n</code></pre>"},{"location":"emane/files.html#phy-xml","title":"PHY XML","text":"<p>PHY layer configuration settings would be found in this file. CORE will write out all values, even if the value is a default value.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# cat eth0-phy.xml\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;!DOCTYPE phy SYSTEM \"file:///usr/share/emane/dtd/phy.dtd\"&gt;\n&lt;phy name=\"emane_rfpipe PHY\"&gt;\n  &lt;param name=\"bandwidth\" value=\"1000000\"/&gt;\n  &lt;param name=\"fading.model\" value=\"none\"/&gt;\n  &lt;param name=\"fading.nakagami.distance0\" value=\"100.000000\"/&gt;\n  &lt;param name=\"fading.nakagami.distance1\" value=\"250.000000\"/&gt;\n  &lt;param name=\"fading.nakagami.m0\" value=\"0.750000\"/&gt;\n  &lt;param name=\"fading.nakagami.m1\" value=\"1.000000\"/&gt;\n  &lt;param name=\"fading.nakagami.m2\" value=\"200.000000\"/&gt;\n  &lt;param name=\"fixedantennagain\" value=\"0.000000\"/&gt;\n  &lt;param name=\"fixedantennagainenable\" value=\"1\"/&gt;\n  &lt;param name=\"frequency\" value=\"2347000000\"/&gt;\n  &lt;param name=\"frequencyofinterest\" value=\"2347000000\"/&gt;\n  &lt;param name=\"noisebinsize\" value=\"20\"/&gt;\n  &lt;param name=\"noisemaxclampenable\" value=\"0\"/&gt;\n  &lt;param name=\"noisemaxmessagepropagation\" value=\"200000\"/&gt;\n  &lt;param name=\"noisemaxsegmentduration\" value=\"1000000\"/&gt;\n  &lt;param name=\"noisemaxsegmentoffset\" value=\"300000\"/&gt;\n  &lt;param name=\"noisemode\" value=\"none\"/&gt;\n  &lt;param name=\"propagationmodel\" value=\"2ray\"/&gt;\n  &lt;param name=\"subid\" value=\"1\"/&gt;\n  &lt;param name=\"systemnoisefigure\" value=\"4.000000\"/&gt;\n  &lt;param name=\"timesyncthreshold\" value=\"10000\"/&gt;\n  &lt;param name=\"txpower\" value=\"0.000000\"/&gt;\n&lt;/phy&gt;\n</code></pre>"},{"location":"emane/files.html#transport-xml","title":"Transport XML","text":"<pre><code>root@n1:/tmp/pycore.46777/n1.conf# cat eth0-trans-virtual.xml\n&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;!DOCTYPE transport SYSTEM \"file:///usr/share/emane/dtd/transport.dtd\"&gt;\n&lt;transport name=\"Virtual Transport\" library=\"transvirtual\"&gt;\n  &lt;param name=\"bitrate\" value=\"0\"/&gt;\n  &lt;param name=\"devicepath\" value=\"/dev/net/tun\"/&gt;\n&lt;/transport&gt;\n</code></pre>"},{"location":"emane/gpsd.html","title":"EMANE GPSD Integration","text":""},{"location":"emane/gpsd.html#overview","title":"Overview","text":"<p>Introduction to integrating gpsd in CORE with EMANE.</p> <p>EMANE Demo 0 may provide more helpful details.</p> <p>Warning</p> <p>Requires installation of gpsd</p>"},{"location":"emane/gpsd.html#run-demo","title":"Run Demo","text":"<ol> <li>Select <code>Open...</code> within the GUI</li> <li>Load <code>emane-demo-gpsd.xml</code></li> <li>Click </li> <li>After startup completes, double click n1 to bring up the nodes terminal</li> </ol>"},{"location":"emane/gpsd.html#example-demo","title":"Example Demo","text":"<p>This section will cover how to run a gpsd location agent within EMANE, that will write out locations to a pseudo terminal file. That file can be read in by the gpsd server and make EMANE location events available to gpsd clients.</p>"},{"location":"emane/gpsd.html#emane-gpsd-event-daemon","title":"EMANE GPSD Event Daemon","text":"<p>First create an <code>eventdaemon.xml</code> file on n1 with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventdaemon SYSTEM \"file:///usr/share/emane/dtd/eventdaemon.dtd\"&gt;\n&lt;eventdaemon nemid=\"1\"&gt;\n    &lt;param name=\"eventservicegroup\" value=\"224.1.2.8:45703\"/&gt;\n    &lt;param name=\"eventservicedevice\" value=\"ctrl0\"/&gt;\n    &lt;agent definition=\"gpsdlocationagent.xml\"/&gt;\n&lt;/eventdaemon&gt;\n</code></pre> <p>Then create the <code>gpsdlocationagent.xml</code> file on n1 with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventagent SYSTEM \"file:///usr/share/emane/dtd/eventagent.dtd\"&gt;\n&lt;eventagent library=\"gpsdlocationagent\"&gt;\n    &lt;param name=\"pseudoterminalfile\" value=\"gps.pty\"/&gt;\n&lt;/eventagent&gt;\n</code></pre> <p>Start the EMANE event agent. This will facilitate feeding location events out to a pseudo terminal file defined above.</p> <pre><code>emaneeventd eventdaemon.xml -r -d -l 3 -f emaneeventd.log\n</code></pre> <p>Start gpsd, reading in the pseudo terminal file.</p> <pre><code>gpsd -G -n -b $(cat gps.pty)\n</code></pre>"},{"location":"emane/gpsd.html#emane-eel-event-daemon","title":"EMANE EEL Event Daemon","text":"<p>EEL Events will be played out from the actual host machine over the designated control network interface. Create the following files in the same directory somewhere on your host.</p> <p>Note</p> <p>Make sure the below eventservicedevice matches the control network device being used on the host for EMANE</p> <p>Create <code>eventservice.xml</code> on the host machine with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventservice SYSTEM \"file:///usr/share/emane/dtd/eventservice.dtd\"&gt;\n&lt;eventservice&gt;\n    &lt;param name=\"eventservicegroup\" value=\"224.1.2.8:45703\"/&gt;\n    &lt;param name=\"eventservicedevice\" value=\"b.9001.1\"/&gt;\n    &lt;generator definition=\"eelgenerator.xml\"/&gt;\n&lt;/eventservice&gt;\n</code></pre> <p>Create <code>eelgenerator.xml</code> on the host machine with the following contents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE eventgenerator SYSTEM \"file:///usr/share/emane/dtd/eventgenerator.dtd\"&gt;\n&lt;eventgenerator library=\"eelgenerator\"&gt;\n    &lt;param name=\"inputfile\" value=\"scenario.eel\"/&gt;\n    &lt;paramlist name=\"loader\"&gt;\n        &lt;item value=\"commeffect:eelloadercommeffect:delta\"/&gt;\n        &lt;item value=\"location,velocity,orientation:eelloaderlocation:delta\"/&gt;\n        &lt;item value=\"pathloss:eelloaderpathloss:delta\"/&gt;\n        &lt;item value=\"antennaprofile:eelloaderantennaprofile:delta\"/&gt;\n    &lt;/paramlist&gt;\n&lt;/eventgenerator&gt;\n</code></pre> <p>Create <code>scenario.eel</code> file with the following contents.</p> <pre><code>0.0  nem:1 location gps 40.031075,-74.523518,3.000000\n0.0  nem:2 location gps 40.031165,-74.523412,3.000000\n</code></pre> <p>Start the EEL event service, which will send the events defined in the file above over the control network to all EMANE nodes. These location events will be received and provided to gpsd. This allows gpsd client to connect to and get gps locations.</p> <pre><code>emaneeventservice eventservice.xml -l 3\n</code></pre>"},{"location":"emane/precomputed.html","title":"EMANE Procomputed","text":""},{"location":"emane/precomputed.html#overview","title":"Overview","text":"<p>Introduction to using the precomputed propagation model.</p> <p>EMANE Demo 1 for more specifics.</p>"},{"location":"emane/precomputed.html#run-demo","title":"Run Demo","text":"<ol> <li>Select <code>Open...</code> within the GUI</li> <li>Load <code>emane-demo-precomputed.xml</code></li> <li>Click </li> <li>After startup completes, double click n1 to bring up the nodes terminal</li> </ol>"},{"location":"emane/precomputed.html#example-demo","title":"Example Demo","text":"<p>This demo is using the RF Pipe model with the propagation model set to precomputed.</p>"},{"location":"emane/precomputed.html#failed-pings","title":"Failed Pings","text":"<p>Due to using precomputed and having not sent any pathloss events, the nodes cannot ping each other yet.</p> <p>Open a terminal on n1.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# ping 10.0.0.2\nconnect: Network is unreachable\n</code></pre>"},{"location":"emane/precomputed.html#emane-shell","title":"EMANE Shell","text":"<p>You can leverage <code>emanesh</code> to investigate why packets are being dropped.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# emanesh localhost get table nems phy BroadcastPacketDropTable0 UnicastPacketDropTable0\nnem 1   phy BroadcastPacketDropTable0\n| NEM | Out-of-Band | Rx Sensitivity | Propagation Model | Gain Location | Gain Horizon | Gain Profile | Not FOI | Spectrum Clamp | Fade Location | Fade Algorithm | Fade Select |\n| 2   | 0           | 0              | 169               | 0             | 0            | 0            | 0       | 0              | 0             | 0              | 0           |\n\nnem 1   phy UnicastPacketDropTable0\n| NEM | Out-of-Band | Rx Sensitivity | Propagation Model | Gain Location | Gain Horizon | Gain Profile | Not FOI | Spectrum Clamp | Fade Location | Fade Algorithm | Fade Select |\n</code></pre> <p>In the example above we can see that the reason packets are being dropped is due to the propogation model and that is because we have not issued any pathloss events. You can run another command to validate if you have received any pathloss events.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# emanesh localhost get table nems phy  PathlossEventInfoTable\nnem 1   phy PathlossEventInfoTable\n| NEM | Forward Pathloss | Reverse Pathloss |\n</code></pre>"},{"location":"emane/precomputed.html#pathloss-events","title":"Pathloss Events","text":"<p>On the host we will send pathloss events from all nems to all other nems.</p> <p>Note</p> <p>Make sure properly specify the right control network device</p> <pre><code>emaneevent-pathloss 1:2 90 -i &lt;controlnet device&gt;\n</code></pre> <p>Now if we check for pathloss events on n2 we will see what was just sent above.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# emanesh localhost get table nems phy  PathlossEventInfoTable\nnem 1   phy PathlossEventInfoTable\n| NEM | Forward Pathloss | Reverse Pathloss |\n| 2   | 90.0             | 90.0\n</code></pre> <p>You should also now be able to ping n1 from n2.</p> <pre><code>root@n1:/tmp/pycore.46777/n1.conf# ping -c 3 10.0.0.2\nPING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=3.06 ms\n64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=2.12 ms\n64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=1.99 ms\n\n--- 10.0.0.2 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2001ms\nrtt min/avg/max/mdev = 1.991/2.393/3.062/0.479 ms\n</code></pre>"},{"location":"services/bird.html","title":"BIRD Internet Routing Daemon","text":""},{"location":"services/bird.html#overview","title":"Overview","text":"<p>The BIRD Internet Routing Daemon is a routing daemon; i.e., a software responsible for managing kernel packet forwarding tables. It aims to develop a dynamic IP routing daemon with full support of all modern routing protocols, easy to use configuration interface and powerful route filtering language, primarily targeted on (but not limited to) Linux and other UNIX-like systems and distributed under the GNU General Public License. BIRD has a free implementation of several well known and common routing and router-supplemental protocols, namely RIP, RIPng, OSPFv2, OSPFv3, BGP, BFD, and NDP/RA. BIRD supports IPv4 and IPv6 address families, Linux kernel and several BSD variants (tested on FreeBSD, NetBSD and OpenBSD). BIRD consists of bird daemon and birdc interactive CLI client used for supervision.</p> <p>In order to be able to use the BIRD Internet Routing Protocol, you must first install the project on your machine.</p>"},{"location":"services/bird.html#bird-package-install","title":"BIRD Package Install","text":"<pre><code>sudo apt-get install bird\n</code></pre>"},{"location":"services/bird.html#bird-source-code-install","title":"BIRD Source Code Install","text":"<p>You can download BIRD source code from its official repository.</p> <pre><code>./configure\nmake\nsu\nmake install\nvi /etc/bird/bird.conf\n</code></pre> <p>The installation will place the bird directory inside /etc where you will also find its config file.</p> <p>In order to be able to do use the Bird Internet Routing Protocol, you must modify bird.conf due to the fact that the given configuration file is not configured beyond allowing the bird daemon to start, which means that nothing else will happen if you run it.</p>"},{"location":"services/emane.html","title":"EMANE Services","text":""},{"location":"services/emane.html#overview","title":"Overview","text":"<p>EMANE related services for CORE.</p>"},{"location":"services/emane.html#transport-service","title":"Transport Service","text":"<p>Helps with setting up EMANE for using an external transport.</p>"},{"location":"services/frr.html","title":"FRRouting","text":""},{"location":"services/frr.html#overview","title":"Overview","text":"<p>FRRouting is a routing software package that provides TCP/IP based routing services with routing protocols support such as BGP, RIP, OSPF, IS-IS and more. FRR also supports special BGP Route Reflector and Route Server behavior. In addition to traditional IPv4 routing protocols, FRR also supports IPv6 routing protocols. With an SNMP daemon that supports the AgentX protocol, FRR provides routing protocol MIB read-only access (SNMP Support).</p> <p>FRR (as of v7.2) currently supports the following protocols:</p> <ul> <li>BGPv4</li> <li>OSPFv2</li> <li>OSPFv3</li> <li>RIPv1/v2/ng</li> <li>IS-IS</li> <li>PIM-SM/MSDP/BSM(AutoRP)</li> <li>LDP</li> <li>BFD</li> <li>Babel</li> <li>PBR</li> <li>OpenFabric</li> <li>VRRPv2/v3</li> <li>EIGRP (alpha)</li> <li>NHRP (alpha)</li> </ul>"},{"location":"services/frr.html#frrouting-package-install","title":"FRRouting Package Install","text":"<p>Ubuntu 19.10 and later</p> <pre><code>sudo apt update &amp;&amp; sudo apt install frr\n</code></pre> <p>Ubuntu 16.04 and Ubuntu 18.04</p> <pre><code>sudo apt install curl\ncurl -s https://deb.frrouting.org/frr/keys.asc | sudo apt-key add -\nFRRVER=\"frr-stable\"\necho deb https://deb.frrouting.org/frr $(lsb_release -s -c) $FRRVER | sudo tee -a /etc/apt/sources.list.d/frr.list\nsudo apt update &amp;&amp; sudo apt install frr frr-pythontools\n</code></pre> <p>Fedora 31</p> <pre><code>sudo dnf update &amp;&amp; sudo dnf install frr\n</code></pre>"},{"location":"services/frr.html#frrouting-source-code-install","title":"FRRouting Source Code Install","text":"<p>Building FRR from source is the best way to ensure you have the latest features and bug fixes. Details for each supported platform, including dependency package listings, permissions, and other gotchas, are in the developer\u2019s documentation.</p> <p>FRR\u2019s source is available on the project GitHub page.</p> <pre><code>git clone https://github.com/FRRouting/frr.git\n</code></pre> <p>Change into your FRR source directory and issue:</p> <pre><code>./bootstrap.sh\n</code></pre> <p>Then, choose the configuration options that you wish to use for the installation. You can find these options on FRR's official webpage. Once you have chosen your configure options, run the configure script and pass the options you chose:</p> <pre><code>./configure \\\n    --prefix=/usr \\\n    --enable-exampledir=/usr/share/doc/frr/examples/ \\\n    --localstatedir=/var/run/frr \\\n    --sbindir=/usr/lib/frr \\\n    --sysconfdir=/etc/frr \\\n    --enable-pimd \\\n    --enable-watchfrr \\\n    ...\n</code></pre> <p>After configuring the software, you are ready to build and install it in your system.</p> <pre><code>make &amp;&amp; sudo make install\n</code></pre> <p>If everything finishes successfully, FRR should be installed.</p>"},{"location":"services/nrl.html","title":"NRL Services","text":""},{"location":"services/nrl.html#overview","title":"Overview","text":"<p>The Protean Protocol Prototyping Library (ProtoLib) is a cross-platform library that allows applications to be built while supporting a variety of platforms including Linux, Windows, WinCE/PocketPC, MacOS, FreeBSD, Solaris, etc as well as the simulation environments of NS2 and Opnet. The goal of the Protolib is to provide a set of simple, cross-platform C++ classes that allow development of network protocols and applications that can run on different platforms and in network simulation environments. While Protolib provides an overall framework for developing working protocol implementations, applications, and simulation modules, the individual classes are designed for use as stand-alone components when possible. Although Protolib is principally for research purposes, the code has been constructed to provide robust, efficient performance and adaptability to real applications. In some cases, the code consists of data structures, etc useful in protocol implementations and, in other cases, provides common, cross-platform interfaces to system services and functions (e.g., sockets, timers, routing tables, etc).</p> <p>Currently, the Naval Research Laboratory uses this library to develop a wide variety of protocols.The NRL Protolib currently supports the following protocols:</p> <ul> <li>MGEN_Sink</li> <li>NHDP</li> <li>SMF</li> <li>OLSR</li> <li>OLSRv2</li> <li>OLSRORG</li> <li>MgenActor</li> <li>arouted</li> </ul>"},{"location":"services/nrl.html#nrl-installation","title":"NRL Installation","text":"<p>In order to be able to use the different protocols that NRL offers, you must first download the support library itself. You can get the source code from their NRL Protolib Repo.</p>"},{"location":"services/nrl.html#multi-generator-mgen","title":"Multi-Generator (MGEN)","text":"<p>Download MGEN from the NRL MGEN Repo, unpack it and copy the protolib library into the main folder mgen. Execute the following commands to build the protocol.</p> <pre><code>cd mgen/makefiles\nmake -f Makefile.{os} mgen\n</code></pre>"},{"location":"services/nrl.html#neighborhood-discovery-protocol-nhdp","title":"Neighborhood Discovery Protocol (NHDP)","text":"<p>Download NHDP from the NRL NHDP Repo.</p> <pre><code>sudo apt-get install libpcap-dev libboost-all-dev\nwget https://github.com/protocolbuffers/protobuf/releases/download/v3.8.0/protoc-3.8.0-linux-x86_64.zip\nunzip protoc-3.8.0-linux-x86_64.zip\n</code></pre> <p>Then place the binaries in your $PATH. To know your paths you can issue the following command</p> <pre><code>echo $PATH\n</code></pre> <p>Go to the downloaded NHDP tarball, unpack it and place the protolib library inside the NHDP main folder. Now, compile the NHDP Protocol.</p> <pre><code>cd nhdp/unix\nmake -f Makefile.{os}\n</code></pre>"},{"location":"services/nrl.html#simplified-multicast-forwarding-smf","title":"Simplified Multicast Forwarding (SMF)","text":"<p>Download SMF from the NRL SMF Repo , unpack it and place the protolib library inside the smf main folder.</p> <pre><code>cd mgen/makefiles\nmake -f Makefile.{os}\n</code></pre>"},{"location":"services/nrl.html#optimized-link-state-routing-protocol-olsr","title":"Optimized Link State Routing Protocol (OLSR)","text":"<p>To install the OLSR protocol, download their source code from their NRL OLSR Repo. Unpack it and place the previously downloaded protolib library inside the nrlolsr main directory. Then execute the following commands:</p> <pre><code>cd ./unix\nmake -f Makefile.{os}\n</code></pre>"},{"location":"services/quagga.html","title":"Quagga Routing Suite","text":""},{"location":"services/quagga.html#overview","title":"Overview","text":"<p>Quagga is a routing software suite, providing implementations of OSPFv2, OSPFv3, RIP v1 and v2, RIPng and BGP-4 for Unix platforms, particularly FreeBSD, Linux, Solaris and NetBSD. Quagga is a fork of GNU Zebra which was developed by Kunihiro Ishiguro. The Quagga architecture consists of a core daemon, zebra, which acts as an abstraction layer to the underlying Unix kernel and presents the Zserv API over a Unix or TCP stream to Quagga clients. It is these Zserv clients which typically implement a routing protocol and communicate routing updates to the zebra daemon.</p>"},{"location":"services/quagga.html#quagga-package-install","title":"Quagga Package Install","text":"<pre><code>sudo apt-get install quagga\n</code></pre>"},{"location":"services/quagga.html#quagga-source-install","title":"Quagga Source Install","text":"<p>First, download the source code from their official webpage.</p> <pre><code>sudo apt-get install gawk\n</code></pre> <p>Extract the tarball, go to the directory of your currently extracted code and issue the following commands.</p> <pre><code>./configure\nmake\nsudo make install\n</code></pre>"},{"location":"services/sdn.html","title":"Software Defined Networking","text":""},{"location":"services/sdn.html#overview","title":"Overview","text":"<p>Ryu is a component-based software defined networking framework. Ryu provides software components with well defined API that make it easy for developers to create new network management and control applications. Ryu supports various protocols for managing network devices, such as OpenFlow, Netconf, OF-config, etc. About OpenFlow, Ryu supports fully 1.0, 1.2, 1.3, 1.4, 1.5 and Nicira Extensions. All of the code is freely available under the Apache 2.0 license.</p>"},{"location":"services/sdn.html#installation","title":"Installation","text":""},{"location":"services/sdn.html#prerequisites","title":"Prerequisites","text":"<pre><code>sudo apt-get install gcc python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev zlib1g-dev\n</code></pre>"},{"location":"services/sdn.html#ryu-package-install","title":"Ryu Package Install","text":"<pre><code>pip install ryu\n</code></pre>"},{"location":"services/sdn.html#ryu-source-install","title":"Ryu Source Install","text":"<pre><code>git clone git://github.com/osrg/ryu.git\ncd ryu\npip install .\n</code></pre>"},{"location":"services/security.html","title":"Security Services","text":""},{"location":"services/security.html#overview","title":"Overview","text":"<p>The security services offer a wide variety of protocols capable of satisfying the most use cases available. Security services such as IP security protocols, for providing security at the IP layer, as well as the suite of protocols designed to provide that security, through authentication and encryption of IP network packets. Virtual Private Networks (VPNs) and Firewalls are also available for use to the user.</p>"},{"location":"services/security.html#installation","title":"Installation","text":"<p>Libraries needed for some security services.</p> <pre><code>sudo apt-get install ipsec-tools racoon\n</code></pre>"},{"location":"services/security.html#openvpn","title":"OpenVPN","text":"<p>Below is a set of instruction for running a very simple OpenVPN client/server scenario.</p>"},{"location":"services/security.html#installation_1","title":"Installation","text":"<pre><code># install openvpn\nsudo apt install openvpn\n\n# retrieve easyrsa3 for key/cert generation\ngit clone https://github.com/OpenVPN/easy-rsa\n</code></pre>"},{"location":"services/security.html#generating-keyscerts","title":"Generating Keys/Certs","text":"<pre><code># navigate into easyrsa3 repo subdirectory that contains built binary\ncd easy-rsa/easyrsa3\n\n# initalize pki\n./easyrsa init-pki\n\n# build ca\n./easyrsa build-ca\n\n# generate and sign server keypair(s)\nSERVER_NAME=server1\n./easyrsa get-req $SERVER_NAME nopass\n./easyrsa sign-req server $SERVER_NAME\n\n# generate and sign client keypair(s)\nCLIENT_NAME=client1\n./easyrsa get-req $CLIENT_NAME nopass\n./easyrsa sign-req client $CLIENT_NAME\n\n# DH generation\n./easyrsa gen-dh\n\n# create directory for keys for CORE to use\n# NOTE: the default is set to a directory that requires using sudo, but can be\n# anywhere and not require sudo at all\nKEYDIR=/opt/core/etc/keys\nsudo mkdir $KEYDIR\n\n# move keys to directory\nsudo cp pki/ca.crt $KEYDIR\nsudo cp pki/issued/*.crt $KEYDIR\nsudo cp pki/private/*.key $KEYDIR\nsudo cp pki/dh.pem $KEYDIR/dh1024.pem\n</code></pre>"},{"location":"services/security.html#configure-server-nodes","title":"Configure Server Nodes","text":"<p>Add VPNServer service to nodes desired for running an OpenVPN server.</p> <p>Modify sampleVPNServer for the following</p> <ul> <li>Edit keydir key/cert directory</li> <li>Edit keyname to use generated server name above</li> <li>Edit vpnserver to match an address that the server node will have</li> </ul>"},{"location":"services/security.html#configure-client-nodes","title":"Configure Client Nodes","text":"<p>Add VPNClient service to nodes desired for acting as an OpenVPN client.</p> <p>Modify sampleVPNClient for the following</p> <ul> <li>Edit keydir key/cert directory</li> <li>Edit keyname to use generated client name above</li> <li>Edit vpnserver to match the address a server was configured to use</li> </ul>"},{"location":"services/utility.html","title":"Utility Services","text":""},{"location":"services/utility.html#overview","title":"Overview","text":"<p>Variety of convenience services for carrying out common networking changes.</p> <p>The following services are provided as utilities:</p> <ul> <li>UCARP</li> <li>IP Forward</li> <li>Default Routing</li> <li>Default Muticast Routing</li> <li>Static Routing</li> <li>SSH</li> <li>DHCP</li> <li>DHCP Client</li> <li>FTP</li> <li>HTTP</li> <li>PCAP</li> <li>RADVD</li> <li>ATD</li> </ul>"},{"location":"services/utility.html#installation","title":"Installation","text":"<p>To install the functionality of the previously metioned services you can run the following command:</p> <pre><code>sudo apt-get install isc-dhcp-server apache2 libpcap-dev radvd at\n</code></pre>"},{"location":"services/utility.html#ucarp","title":"UCARP","text":"<p>UCARP allows a couple of hosts to share common virtual IP addresses in order to provide automatic failover. It is a portable userland implementation of the secure and patent-free Common Address Redundancy Protocol (CARP, OpenBSD's alternative to the patents-bloated VRRP).</p> <p>Strong points of the CARP protocol are: very low overhead, cryptographically signed messages, interoperability between different operating systems and no need for any dedicated extra network link between redundant hosts.</p>"},{"location":"services/utility.html#installation_1","title":"Installation","text":"<pre><code>sudo apt-get install ucarp\n</code></pre>"},{"location":"services/xorp.html","title":"XORP routing suite","text":""},{"location":"services/xorp.html#overview","title":"Overview","text":"<p>XORP is an open networking platform that supports OSPF, RIP, BGP, OLSR, VRRP, PIM, IGMP (Multicast) and other routing protocols. Most protocols support IPv4 and IPv6 where applicable. It is known to work on various Linux distributions and flavors of BSD.</p> <p>XORP started life as a project at the ICSI Center for Open Networking (ICON) at the International Computer Science Institute in Berkeley, California, USA, and spent some time with the team at XORP, Inc. It is now maintained and improved on a volunteer basis by a core of long-term XORP developers and some newer contributors.</p> <p>XORP's primary goal is to be an open platform for networking protocol implementations and an alternative to proprietary and closed networking products in the marketplace today. It is the only open source platform to offer integrated multicast capability.</p> <p>XORP design philosophy is:</p> <ul> <li>modularity</li> <li>extensibility</li> <li>performance</li> <li>robustness   This is achieved by carefully separating functionalities into independent modules, and by providing an API for each   module.</li> </ul> <p>XORP divides into two subsystems. The higher-level (\"user-level\") subsystem consists of the routing protocols. The lower-level (\"kernel\") manages the forwarding path, and provides APIs for the higher-level to access.</p> <p>User-level XORP uses multi-process architecture with one process per routing protocol, and a novel inter-process communication mechanism called XRL (XORP Resource Locator).</p> <p>The lower-level subsystem can use traditional UNIX kernel forwarding, or Click modular router. The modularity and independency of the lower-level from the user-level subsystem allows for its easily replacement with other solutions including high-end hardware-based forwarding engines.</p>"},{"location":"services/xorp.html#installation","title":"Installation","text":"<p>In order to be able to install the XORP Routing Suite, you must first install scons in order to compile it.</p> <pre><code>sudo apt-get install scons\n</code></pre> <p>Then, download XORP from its official release web page.</p> <pre><code>http://www.xorp.org/releases/current/\ncd xorp\nsudo apt-get install libssl-dev ncurses-dev\nscons\nscons install\n</code></pre>"},{"location":"tutorials/overview.html","title":"CORE Tutorials","text":"<p>These tutorials will cover various use cases within CORE. These tutorials will provide example python, gRPC, XML, and related files, as well as an explanation for their usage and purpose.</p>"},{"location":"tutorials/overview.html#checklist","title":"Checklist","text":"<p>These are the items you should become familiar with for running all the tutorials below.</p> <ul> <li>Install CORE</li> <li>Tutorial Setup</li> </ul>"},{"location":"tutorials/overview.html#tutorials","title":"Tutorials","text":"<ul> <li>Tutorial 1 - Wired Network<ul> <li>Covers interactions when using a simple 2 node wired network</li> </ul> </li> <li>Tutorial 2 - Wireless Network<ul> <li>Covers interactions when using a simple 3 node wireless network</li> </ul> </li> <li>Tutorial 3 - Basic Mobility<ul> <li>Covers mobility interactions when using a simple 3 node wireless network</li> </ul> </li> <li>Tutorial 4 - Tests<ul> <li>Covers automating scenarios as tests to validate software</li> </ul> </li> <li>Tutorial 5 - RJ45 Node<ul> <li>Covers using the RJ45 node to connect a Windows OS</li> </ul> </li> <li>Tutorial 6 - Improve Visuals<ul> <li>Covers changing the look of a scenario within the CORE GUI</li> </ul> </li> <li>Tutorial 7 - EMANE<ul> <li>Covers using EMANE within CORE for higher fidelity RF networks</li> </ul> </li> </ul>"},{"location":"tutorials/setup.html","title":"Tutorial Setup","text":""},{"location":"tutorials/setup.html#setup-for-core","title":"Setup for CORE","text":"<p>We assume the prior installation of CORE, using a virtual environment.</p> <pre><code># location of all core files\n/opt/core\n\n# location of the virtual environment\n/opt/core/venv\n\n# convenience command for using core's python virtual environment\ncore-python\n</code></pre>"},{"location":"tutorials/setup.html#setup-for-chat-app","title":"Setup for Chat App","text":"<p>There is a simple TCP chat app provided as example software to use and run within the tutorials provided.</p>"},{"location":"tutorials/setup.html#installation","title":"Installation","text":"<p>The following will install chatapp and its scripts into /usr/local, which you may need to add to PATH within node to be able to use command directly.</p> <pre><code>cd /opt/core/share/tutorials/chatapp\nsudo python3 -m pip install .\n</code></pre> <p>Note</p> <p>Some Linux distros will not have /usr/local in their PATH and you will need to compensate.</p> <pre><code>export PATH=$PATH:/usr/local\n</code></pre>"},{"location":"tutorials/setup.html#running-the-server","title":"Running the Server","text":"<p>The server will print and log connected clients and their messages.</p> <pre><code>usage: chatapp-server [-h] [-a ADDRESS] [-p PORT]\n\nchat app server\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a ADDRESS, --address ADDRESS\n                        address to listen on (default: )\n  -p PORT, --port PORT  port to listen on (default: 9001)\n</code></pre>"},{"location":"tutorials/setup.html#running-the-client","title":"Running the Client","text":"<p>The client will print and log messages from other clients and their join/leave status.</p> <pre><code>usage: chatapp-client [-h] -a ADDRESS [-p PORT]\n\nchat app client\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a ADDRESS, --address ADDRESS\n                        address to listen on (default: None)\n  -p PORT, --port PORT  port to listen on (default: 9001)\n</code></pre>"},{"location":"tutorials/setup.html#installing-the-chat-app-service","title":"Installing the Chat App Service","text":"<ol> <li>You will first need to edit /opt/core/etc/core.conf to update the custom    service path to pick up your service     <pre><code>custom_services_dir = &lt;path for service&gt;\n</code></pre></li> <li>Then you will need to copy/move /opt/core/share/tutorials/chatapp/chatapp_service.py to the directory    configured above</li> <li>Then you will need to restart the core-daemon to pick up this new service</li> <li>Now the service will be an available option under the group ChatApp with    the name ChatApp Server</li> </ol>"},{"location":"tutorials/tutorial1.html","title":"Tutorial 1 - Wired Network","text":""},{"location":"tutorials/tutorial1.html#overview","title":"Overview","text":"<p>This tutorial will cover some use cases when using a wired 2 node scenario in CORE.</p> <p> </p>"},{"location":"tutorials/tutorial1.html#files","title":"Files","text":"<p>Below is the list of files used for this tutorial.</p> <ul> <li>2 node wired scenario<ul> <li>/opt/core/share/tutorials/tutorial1/scenario.xml</li> <li>/opt/core/share/tutorials/tutorial1/scenario.py</li> </ul> </li> <li>2 node wired scenario, with n1 running the \"Chat App Server\" service<ul> <li>/opt/core/share/tutorials/tutorial1/scenario_service.xml</li> <li>/opt/core/share/tutorials/tutorial1/scenario_service.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial1.html#running-this-tutorial","title":"Running this Tutorial","text":"<p>This section covers interactions that can be carried out for this scenario.</p> <p>Our scenario has the following nodes and addresses:</p> <ul> <li>n1 - 10.0.0.20</li> <li>n2 - 10.0.0.21</li> </ul> <p>All usages below assume a clean scenario start.</p>"},{"location":"tutorials/tutorial1.html#using-ping","title":"Using Ping","text":"<p>Using the command line utility ping can be a good way to verify connectivity between nodes in CORE.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n1 by double clicking it in the GUI</p> </li> <li>Run the following in n1 terminal     <pre><code>ping -c 3 10.0.0.21\n</code></pre></li> <li>You should see the following output     <pre><code>PING 10.0.0.21 (10.0.0.21) 56(84) bytes of data.\n64 bytes from 10.0.0.21: icmp_seq=1 ttl=64 time=0.085 ms\n64 bytes from 10.0.0.21: icmp_seq=2 ttl=64 time=0.079 ms\n64 bytes from 10.0.0.21: icmp_seq=3 ttl=64 time=0.072 ms\n\n--- 10.0.0.21 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 1999ms\nrtt min/avg/max/mdev = 0.072/0.078/0.085/0.011 ms\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial1.html#using-tcpdump","title":"Using Tcpdump","text":"<p>Using tcpdump can be very beneficial for examining a network. You can verify traffic being sent/received among many other uses.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n1 by double clicking it in the GUI</p> </li> <li>Open a terminal on n2 by double clicking it in the GUI</li> <li>Run the following in n2 terminal     <pre><code>tcpdump -lenni eth0\n</code></pre></li> <li>Run the following in n1 terminal     <pre><code>ping -c 1 10.0.0.21\n</code></pre></li> <li>You should see the following in n2 terminal     <pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes\n10:23:04.685292 00:00:00:aa:00:00 &gt; 00:00:00:aa:00:01, ethertype IPv4 (0x0800), length 98: 10.0.0.20 &gt; 10.0.0.21: ICMP echo request, id 67, seq 1, length 64\n10:23:04.685329 00:00:00:aa:00:01 &gt; 00:00:00:aa:00:00, ethertype IPv4 (0x0800), length 98: 10.0.0.21 &gt; 10.0.0.20: ICMP echo reply, id 67, seq 1, length 64\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial1.html#editing-a-link","title":"Editing a Link","text":"<p>You can edit links between nodes in CORE to modify loss, delay, bandwidth, and more. This can be beneficial for understanding how software will behave in adverse conditions.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Right click the link between n1 and n2</p> </li> <li> <p>Select Configure <p> </p></p> </li> <li> <p>Update the loss to 25 <p> </p></p> </li> <li> <p>Open a terminal on n1 by double clicking it in the GUI</p> </li> <li>Run the following in n1 terminal     <pre><code>ping -c 10 10.0.0.21\n</code></pre></li> <li>You should see something similar for the summary output, reflecting the change in loss     <pre><code>--- 10.0.0.21 ping statistics ---\n10 packets transmitted, 6 received, 40% packet loss, time 9000ms\nrtt min/avg/max/mdev = 0.077/0.093/0.108/0.016 ms\n</code></pre></li> <li>Remember that the loss above is compounded, since a ping and the loss applied occurs in both directions</li> </ul>"},{"location":"tutorials/tutorial1.html#running-software","title":"Running Software","text":"<p>We will now leverage the installed Chat App software to stand up a server and client within the nodes of our scenario.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n1 by double clicking it in the GUI</p> </li> <li>Run the following in n1 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>Open a terminal on n2 by double clicking it in the GUI</li> <li>Run the following in n2 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.20\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.21:44362 joining\n</code></pre></li> <li>Type the following in n2 terminal and hit enter     <pre><code>hello world\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.21:44362 joining\n[10.0.0.21:44362] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial1.html#tailing-a-log","title":"Tailing a Log","text":"<p>In this case we are using the service based scenario. This will automatically start and run the Chat App Server on n1 and log to a file. This case will demonstrate using <code>tail -f</code> to observe the output of running software.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario_service.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n1 by double clicking it in the GUI</p> </li> <li>Run the following in n1 terminal     <pre><code>tail -f chatapp.log\n</code></pre></li> <li>Open a terminal on n2 by double clicking it in the GUI</li> <li>Run the following in n2 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.20\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.21:44362 joining\n</code></pre></li> <li>Type the following in n2 terminal and hit enter     <pre><code>hello world\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.21:44362 joining\n[10.0.0.21:44362] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial1.html#grpc-python-scripts","title":"gRPC Python Scripts","text":"<p>You can also run the same steps above, using the provided gRPC script versions of scenarios. Below are the steps to run and join one of these scenario, then you can continue with the remaining steps of a given section.</p> <ol> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>From another terminal run the tutorial python script, which will create a session to join     <pre><code>/opt/core/venv/bin/python scenario.py\n</code></pre></li> <li>In another terminal run the CORE GUI     <pre><code>core-gui\n</code></pre></li> <li>You will be presented with sessions to join, select the one created by the script   <p> </p> </li> </ol>"},{"location":"tutorials/tutorial2.html","title":"Tutorial 2 - Wireless Network","text":""},{"location":"tutorials/tutorial2.html#overview","title":"Overview","text":"<p>This tutorial will cover the use of a 3 node scenario in CORE. Then running a chat server on one node and a chat client on the other. The client will send a simple message and the server will log receipt of the message.</p>"},{"location":"tutorials/tutorial2.html#files","title":"Files","text":"<p>Below is the list of files used for this tutorial.</p> <ul> <li>3 node CORE xml scenario file  (wireless)<ul> <li>/opt/core/share/tutorials/tutorial2/scenario.xml</li> </ul> </li> <li>3 node CORE gRPC python script (wireless)<ul> <li>/opt/core/share/tutorials/tutorial2/scenario.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial2.html#running-with-the-xml-scenario-file","title":"Running with the XML Scenario File","text":"<p>This section will cover running this sample tutorial using the XML scenario file, leveraging an NS2 mobility file.</p> <ul> <li>Make sure the core-daemon is running a terminal    <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI    <pre><code>core-gui\n</code></pre></li> <li>In the GUI menu bar select File-&gt;Open...</li> <li>Navigate to and select this tutorials scenario.xml file</li> <li> <p>You can now click play to start the session   <p> </p></p> </li> <li> <p>Note that OSPF routing protocol is included in the scenario to provide routes to other nodes, as they are discovered</p> </li> <li>Double click node n4 to open a terminal and ping node n2 <pre><code>ping  -c 2 10.0.0.2\nPING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=63 time=20.2 ms\n64 bytes from 10.0.0.2: icmp_seq=2 ttl=63 time=20.2 ms\n\n--- 10.0.0.2 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1000ms\nrtt min/avg/max/mdev = 20.168/20.173/20.178/0.005 ms\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial2.html#configuring-delay","title":"Configuring Delay","text":"<ul> <li> <p>Right click on the wlan1 node and select WLAN Config, then set delay to 500000   <p> </p></p> </li> <li> <p>Using the open terminal for node n4, ping n2 again, expect about 2 seconds delay    <pre><code>ping -c 5 10.0.0.2\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=63 time=2001 ms\n64 bytes from 10.0.0.2: icmp_seq=2 ttl=63 time=2000 ms\n64 bytes from 10.0.0.2: icmp_seq=3 ttl=63 time=2000 ms\n64 bytes from 10.0.0.2: icmp_seq=4 ttl=63 time=2000 ms\n64 bytes from 10.0.0.2: icmp_seq=5 ttl=63 time=2000 ms\n\n--- 10.0.0.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 4024ms\nrtt min/avg/max/mdev = 2000.176/2000.438/2001.166/0.376 ms, pipe 2\n</code></pre></p> </li> </ul>"},{"location":"tutorials/tutorial2.html#configure-loss","title":"Configure Loss","text":"<ul> <li> <p>Right click on the wlan1 node and select WLAN Config, set delay back to 5000 and loss to 10   <p> </p></p> </li> <li> <p>Using the open terminal for node n4, ping n2 again, expect to notice considerable loss     <pre><code>ping  -c 10 10.0.0.2\nPING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=63 time=20.4 ms\n64 bytes from 10.0.0.2: icmp_seq=2 ttl=63 time=20.5 ms\n64 bytes from 10.0.0.2: icmp_seq=3 ttl=63 time=20.2 ms\n64 bytes from 10.0.0.2: icmp_seq=4 ttl=63 time=20.8 ms\n64 bytes from 10.0.0.2: icmp_seq=5 ttl=63 time=21.9 ms\n64 bytes from 10.0.0.2: icmp_seq=8 ttl=63 time=22.7 ms\n64 bytes from 10.0.0.2: icmp_seq=9 ttl=63 time=22.4 ms\n64 bytes from 10.0.0.2: icmp_seq=10 ttl=63 time=20.3 ms\n\n--- 10.0.0.2 ping statistics ---\n10 packets transmitted, 8 received, 20% packet loss, time 9064ms\nrtt min/avg/max/mdev = 20.188/21.143/22.717/0.967 ms\n</code></pre></p> </li> <li>Make sure to set loss back to 0 when done</li> </ul>"},{"location":"tutorials/tutorial2.html#running-with-the-grpc-python-script","title":"Running with the gRPC Python Script","text":"<p>This section will cover running this sample tutorial using the gRPC python script and providing mobility over the gRPC interface.</p> <ul> <li>Make sure the core-daemon is running a terminal    <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI    <pre><code>core-gui\n</code></pre></li> <li>From another terminal run the scenario.py script    <pre><code>/opt/core/venv/bin/python scenario.py\n</code></pre></li> <li>In the GUI dialog box select the session and click connect</li> <li>You will now have joined the already running scenario</li> </ul> <p> </p>"},{"location":"tutorials/tutorial2.html#running-software","title":"Running Software","text":"<p>We will now leverage the installed Chat App software to stand up a server and client within the nodes of our scenario. You can use the bases of the running scenario from either scenario.xml or the scenario.py gRPC script.</p> <ul> <li>In the GUI double click on node n4, this will bring up a terminal for this node</li> <li>In the n4 terminal, run the server    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>In the GUI double click on node n2, this will bring up a terminal for this node</li> <li>In the n2 terminal, run the client    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.4\n</code></pre></li> <li>This will result in n2 connecting to the server</li> <li>In the n2 terminal, type a message at the client prompt    <pre><code>&gt;&gt;hello world\n</code></pre></li> <li>Observe that text typed at client then appears in the terminal of n4 <pre><code>chat server listening on: :9001\n[server] 10.0.0.2:53684 joining\n[10.0.0.2:53684] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial3.html","title":"Tutorial 3 - Basic Mobility","text":""},{"location":"tutorials/tutorial3.html#overview","title":"Overview","text":"<p>This tutorial will cover using a 3 node scenario in CORE with basic mobility. Mobility can be provided from a NS2 file or by including mobility commands in a gRPC script.</p>"},{"location":"tutorials/tutorial3.html#files","title":"Files","text":"<p>Below is the list of files used for this tutorial.</p> <ul> <li>NS2 mobility input file<ul> <li>/opt/core/share/tutorials/tutorial3/movements1.txt</li> </ul> </li> <li>3 node CORE xml scenario file  (wireless)<ul> <li>/opt/core/share/tutorials/tutorial3/scenario.xml</li> </ul> </li> <li>3 node CORE gRPC python script (wireless)<ul> <li>/opt/core/share/tutorials/tutorial3/scenario.py</li> </ul> </li> <li>event listener<ul> <li>/opt/core/share/tutorials/tutorial3/printout.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial3.html#running-with-xml-file-using-ns2-movement","title":"Running with XML file using NS2 Movement","text":"<p>This section will cover running this sample tutorial using the XML scenario file, leveraging an NS2 file for mobility.</p> <ul> <li>Make sure the core-daemon is running a terminal    <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI    <pre><code>core-gui\n</code></pre></li> <li>Observe the format of the N2 file, cat movements1.txt. Note that this file was manually developed.    <pre><code>$node_(1) set X_ 208.1\n$node_(1) set Y_ 211.05\n$node_(1) set Z_ 0\n$ns_ at 0.0 \"$node_(1) setdest 208.1 211.05 0.00\"\n$node_(2) set X_ 393.1\n$node_(2) set Y_ 223.05\n$node_(2) set Z_ 0\n$ns_ at 0.0 \"$node_(2) setdest 393.1 223.05 0.00\"\n$node_(4) set X_ 499.1\n$node_(4) set Y_ 186.05\n$node_(4) set Z_ 0\n$ns_ at 0.0 \"$node_(4) setdest 499.1 186.05 0.00\"\n$ns_ at 1.0 \"$node_(1) setdest 190.1 225.05 0.00\"\n$ns_ at 1.0 \"$node_(2) setdest 393.1 225.05 0.00\"\n$ns_ at 1.0 \"$node_(4) setdest 515.1 186.05 0.00\"\n$ns_ at 2.0 \"$node_(1) setdest 175.1 250.05 0.00\"\n$ns_ at 2.0 \"$node_(2) setdest 393.1 250.05 0.00\"\n$ns_ at 2.0 \"$node_(4) setdest 530.1 186.05 0.00\"\n$ns_ at 3.0 \"$node_(1) setdest 160.1 275.05 0.00\"\n$ns_ at 3.0 \"$node_(2) setdest 393.1 275.05 0.00\"\n$ns_ at 3.0 \"$node_(4) setdest 530.1 186.05 0.00\"\n$ns_ at 4.0 \"$node_(1) setdest 160.1 300.05 0.00\"\n$ns_ at 4.0 \"$node_(2) setdest 393.1 300.05 0.00\"\n$ns_ at 4.0 \"$node_(4) setdest 550.1 186.05 0.00\"\n$ns_ at 5.0 \"$node_(1) setdest 160.1 275.05 0.00\"\n$ns_ at 5.0 \"$node_(2) setdest 393.1 275.05 0.00\"\n$ns_ at 5.0 \"$node_(4) setdest 530.1 186.05 0.00\"\n$ns_ at 6.0 \"$node_(1) setdest 175.1 250.05 0.00\"\n$ns_ at 6.0 \"$node_(2) setdest 393.1 250.05 0.00\"\n$ns_ at 6.0 \"$node_(4) setdest 515.1 186.05 0.00\"\n$ns_ at 7.0 \"$node_(1) setdest 190.1 225.05 0.00\"\n$ns_ at 7.0 \"$node_(2) setdest 393.1 225.05 0.00\"\n$ns_ at 7.0 \"$node_(4) setdest 499.1 186.05 0.00\"\n</code></pre></li> <li>In the GUI menu bar select File-&gt;Open..., and select this tutorials scenario.xml file</li> <li>You can now click play to start the session</li> <li>Select the play button on the Mobility Player to start mobility</li> <li>Observe movement of the nodes</li> <li>Note that OSPF routing protocol is included in the scenario to build routing table so that routes to other nodes are   known and when the routes are discovered, ping will work</li> </ul> <p> </p>"},{"location":"tutorials/tutorial3.html#running-with-the-grpc-script","title":"Running with the gRPC Script","text":"<p>This section covers using a gRPC script to create and provide scenario movement.</p> <ul> <li>Make sure the core-daemon is running a terminal    <pre><code>sudo core-daemon\n</code></pre></li> <li>From another terminal run the scenario.py script    <pre><code>/opt/core/venv/bin/python /opt/core/share/tutorials/tutorial3/scenario.py\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li>In the GUI dialog box select the session and click connect</li> <li>You will now have joined the already running scenario</li> <li> <p>In the terminal running the scenario.py, hit a key to start motion   <p> </p></p> </li> <li> <p>Observe the link between n3 and n4 is shown and then as motion continues the link breaks   <p> </p> </p> </li> </ul>"},{"location":"tutorials/tutorial3.html#running-the-chat-app-software","title":"Running the Chat App Software","text":"<p>This section covers using one of the above 2 scenarios to run software within the nodes.</p> <ul> <li>In the GUI double click on n4, this will bring up a terminal for this node</li> <li>in the n4 terminal, run the server    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>In the GUI double click on n2, this will bring up a terminal for this node</li> <li>In the n2 terminal, run the client    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.4\n</code></pre></li> <li>This will result in n2 connecting to the server</li> <li>In the n2 terminal, type a message at the client prompt and hit enter    <pre><code>&gt;&gt;hello world\n</code></pre></li> <li>Observe that text typed at client then appears in the server terminal    <pre><code>chat server listening on: :9001\n[server] 10.0.0.2:53684 joining\n[10.0.0.2:53684] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial3.html#running-mobility-from-a-node","title":"Running Mobility from a Node","text":"<p>This section provides an example for running a script within a node, that leverages a control network in CORE for issuing mobility using the gRPC API.</p> <ul> <li>Edit the following line in /opt/core/etc/core.conf <pre><code>grpcaddress = 0.0.0.0\n</code></pre></li> <li>Start the scenario from the scenario.xml</li> <li>From the GUI open Session -&gt; Options and set Control Network to 172.16.0.0/24</li> <li>Click to play the scenario</li> <li>Double click on n2 to get a terminal window</li> <li>From the terminal window for n2, run the script    <pre><code>/opt/core/venv/bin/python /opt/core/share/tutorials/tutorial3/move-node2.py\n</code></pre></li> <li>Observe that node 2 moves and continues to move</li> </ul> <p> </p>"},{"location":"tutorials/tutorial4.html","title":"Tutorial 4 - Tests","text":""},{"location":"tutorials/tutorial4.html#overview","title":"Overview","text":"<p>A use case for CORE would be to help automate integration tests for running software within a network. This tutorial covers using CORE with the python pytest testing framework. It will show how you can define tests, for different use cases to validate software and outcomes within a defined network. Using pytest, you would create tests using all the standard pytest functionality. Creating a test file, and then defining test functions to run. For these tests, we are leveraging the CORE library directly and the API it provides.</p> <p>Refer to the pytest documentation for indepth information on how to write tests with pytest.</p>"},{"location":"tutorials/tutorial4.html#files","title":"Files","text":"<p>A directory is used for containing your tests. Within this directory we need a conftest.py, which pytest will pick up to help define and provide test fixtures, which will be leveraged within our tests.</p> <ul> <li>tests directory<ul> <li>/opt/core/share/tutorials/tutorial4/tests</li> </ul> </li> <li>file used by pytest to define fixtures, which can be shared across tests<ul> <li>/opt/core/share/tutorials/tutorial4/conftest.py</li> </ul> </li> <li>defines test classes/functions to run<ul> <li>/opt/core/share/tutorials/tutorial4/test_ping.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial4.html#test-fixtures","title":"Test Fixtures","text":"<p>Below are the definitions for fixture you can define to facilitate and make creating CORE based tests easier.</p> <p>The global session fixture creates one CoreEmu object for the entire test session, yields it for testing, and calls shutdown when everything is over.</p> <pre><code>@pytest.fixture(scope=\"session\")\ndef global_session():\n    core = CoreEmu()\n    session = core.create_session()\n    session.set_state(EventTypes.CONFIGURATION_STATE)\n    yield session\n    core.shutdown()\n</code></pre> <p>The regular session fixture leverages the global session fixture. It will set the correct state for each test case, yield the session for a test, and then clear the session after a test finishes to prepare for the next test.</p> <pre><code>@pytest.fixture\ndef session(global_session):\n    global_session.set_state(EventTypes.CONFIGURATION_STATE)\n    yield global_session\n    global_session.clear()\n</code></pre> <p>The ip prefixes fixture help provide a preconfigured convenience for creating and assigning interfaces to nodes, when creating your network within a test. The address subnet can be whatever you desire.</p> <pre><code>@pytest.fixture(scope=\"session\")\ndef ip_prefixes():\n    return IpPrefixes(ip4_prefix=\"10.0.0.0/24\")\n</code></pre>"},{"location":"tutorials/tutorial4.html#test-functions","title":"Test Functions","text":"<p>Within a pytest test file, you have the freedom to create any kind of test you like, but they will all follow a similar formula.</p> <ul> <li>define a test function that will leverage the session and ip prefixes fixtures</li> <li>then create a network to test, using the session fixture</li> <li>run commands within nodes as desired, to test out your use case</li> <li>validate command result or output for expected behavior to pass or fail</li> </ul> <p>In the test below, we create a simple 2 node wired network and validate node1 can ping node2 successfully.</p> <pre><code>def test_success(self, session: Session, ip_prefixes: IpPrefixes):\n    # create nodes\n    node1 = session.add_node(CoreNode)\n    node2 = session.add_node(CoreNode)\n\n    # link nodes together\n    iface1_data = ip_prefixes.create_iface(node1)\n    iface2_data = ip_prefixes.create_iface(node2)\n    session.add_link(node1.id, node2.id, iface1_data, iface2_data)\n\n    # ping node, expect a successful command\n    node1.cmd(f\"ping -c 1 {iface2_data.ip4}\")\n</code></pre>"},{"location":"tutorials/tutorial4.html#install-pytest","title":"Install Pytest","text":"<p>Since we are running an automated test within CORE, we will need to install pytest within the python interpreter used by CORE.</p> <pre><code>sudo /opt/core/venv/bin/python -m pip install pytest\n</code></pre>"},{"location":"tutorials/tutorial4.html#running-tests","title":"Running Tests","text":"<p>You can run your own or the provided tests, by running the following.</p> <pre><code>cd &lt;test directory&gt;\nsudo /opt/core/venv/bin/python -m pytest -v\n</code></pre> <p>If you run the provided tests, you would expect to see the two tests running and passing.</p> <pre><code>tests/test_ping.py::TestPing::test_success PASSED                                [ 50%]\ntests/test_ping.py::TestPing::test_failure PASSED                                [100%]\n</code></pre>"},{"location":"tutorials/tutorial5.html","title":"Tutorial 5 - RJ45 Node","text":""},{"location":"tutorials/tutorial5.html#overview","title":"Overview","text":"<p>This tutorial will cover connecting CORE VM to a Windows host machine using a RJ45 node.</p>"},{"location":"tutorials/tutorial5.html#files","title":"Files","text":"<p>Below is the list of files used for this tutorial.</p> <ul> <li>the scenario with RJ45 unassigned<ul> <li>/opt/core/share/tutorials/tutorial5/scenario.xml</li> </ul> </li> <li>grpc script to create the RJ45 in simple CORE scenario<ul> <li>/opt/core/share/tutorials/tutorial5/scenario.py</li> </ul> </li> <li>chat app client modified for windows<ul> <li>/opt/core/share/tutorials/tutorial5/client_for_windows.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial5.html#running-with-the-saved-xml-file","title":"Running with the Saved XML File","text":"<p>This section covers using the saved scenario.xml file to get and up and running.</p> <ul> <li> <p>Configure the Windows host VM to have a bridged network adapter   <p> </p></p> </li> <li> <p>Make sure the core-daemon is running in a terminal    <pre><code>sudo core-daemon\n</code></pre></p> </li> <li>In another terminal run the GUI    <pre><code>core-gui\n</code></pre></li> <li> <p>Open the scenario.xml with the unassigned RJ45 node   <p> </p></p> </li> <li> <p>Configure the RJ45 node name to use the bridged interface   <p> </p></p> </li> <li> <p>After configuring the RJ45, run the scenario:   <p> </p></p> </li> <li> <p>Double click node n1 to open a terminal and add a route to the Windows host    <pre><code>ip route add 192.168.0.0/24 via 10.0.0.20\n</code></pre></p> </li> <li>On the Windows host using Windows command prompt with administrator privilege, add a route that uses the interface   connected to the associated interface assigned to the RJ45 node     <pre><code># if enp0s3 is ssigned 192.168.0.6/24\nroute add 10.0.0.0 mask 255.255.255.0 192.168.0.6\n</code></pre></li> <li>Now you should be able to ping from the Windows host to n1 <pre><code>C:\\WINDOWS\\system32&gt;ping 10.0.0.20\n\nPinging 10.0.0.20 with 32 bytes of data:\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\n\nPing statistics for 10.0.0.20:\n    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)\nApproximate round trip times in milli-seconds:\n    Minimum = 0ms, Maximum = 0ms, Average = 0ms\n</code></pre></li> <li>After pinging successfully, run the following in the n1 terminal to start the chatapp server    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>On the Windows host, run the client_for_windows.py <pre><code>python3 client_for_windows.py -a 10.0.0.20\nconnected to server(10.0.0.20:9001) as client(192.168.0.6:49960)\n&gt;&gt; .Hello WORLD\n.Hello WORLD Again\n.\n</code></pre></li> <li>Observe output on n1 <pre><code>chat server listening on: :9001\n[server] 192.168.0.6:49960 joining\n[192.168.0.6:49960] Hello WORLD\n[192.168.0.6:49960] Hello WORLD Again\n</code></pre></li> <li>When finished, you can stop the CORE scenario and cleanup</li> <li>On the Windows host remove the added route    <pre><code>route delete 10.0.0.0\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial5.html#running-with-the-grpc-script","title":"Running with the gRPC Script","text":"<p>This section covers leveraging the gRPC script to get up and running.</p> <ul> <li> <p>Configure the Windows host VM to have a bridged network adapter   <p> </p></p> </li> <li> <p>Make sure the core-daemon is running in a terminal    <pre><code>sudo core-daemon\n</code></pre></p> </li> <li>In another terminal run the GUI    <pre><code>core-gui\n</code></pre></li> <li>Run the gRPC script in the VM    <pre><code># use the desired interface name, in this case enp0s3\n/opt/core/venv/bin/python scenario.py enp0s3\n</code></pre></li> <li> <p>In the core-gui connect to the running session that was created   <p> </p></p> </li> <li> <p>Double click node n1 to open a terminal and add a route to the Windows host    <pre><code>ip route add 192.168.0.0/24 via 10.0.0.20\n</code></pre></p> </li> <li>On the Windows host using Windows command prompt with administrator privilege, add a route that uses the interface   connected to the associated interface assigned to the RJ45 node     <pre><code># if enp0s3 is ssigned 192.168.0.6/24\nroute add 10.0.0.0 mask 255.255.255.0 192.168.0.6\n</code></pre></li> <li>Now you should be able to ping from the Windows host to n1 <pre><code>C:\\WINDOWS\\system32&gt;ping 10.0.0.20\n\nPinging 10.0.0.20 with 32 bytes of data:\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\nReply from 10.0.0.20: bytes=32 time&lt;1ms TTL=64\n\nPing statistics for 10.0.0.20:\n    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)\nApproximate round trip times in milli-seconds:\n    Minimum = 0ms, Maximum = 0ms, Average = 0ms\n</code></pre></li> <li>After pinging successfully, run the following in the n1 terminal to start the chatapp server    <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>On the Windows host, run the client_for_windows.py <pre><code>python3 client_for_windows.py -a 10.0.0.20\nconnected to server(10.0.0.20:9001) as client(192.168.0.6:49960)\n&gt;&gt; .Hello WORLD\n.Hello WORLD Again\n.\n</code></pre></li> <li>Observe output on n1 <pre><code>chat server listening on: :9001\n[server] 192.168.0.6:49960 joining\n[192.168.0.6:49960] Hello WORLD\n[192.168.0.6:49960] Hello WORLD Again\n</code></pre></li> <li>When finished, you can stop the CORE scenario and cleanup</li> <li>On the Windows host remove the added route    <pre><code>route delete 10.0.0.0\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial6.html","title":"Tutorial 6 - Improved Visuals","text":""},{"location":"tutorials/tutorial6.html#overview","title":"Overview","text":"<p>This tutorial will cover changing the node icons, changing the background, and changing or hiding links.</p>"},{"location":"tutorials/tutorial6.html#files","title":"Files","text":"<p>Below is the list of files used for this tutorial.</p> <ul> <li>a mobility script for a node<ul> <li>/opt/core/share/tutorials/tutorial6/demo.py</li> </ul> </li> <li>drone icon<ul> <li>/opt/core/share/tutorials/tutorial6/drone.png</li> </ul> </li> <li>background image<ul> <li>/opt/core/share/tutorials/tutorial6/terrain.png</li> </ul> </li> <li>the scenario after making all changes below<ul> <li>/opt/core/share/tutorials/tutorial6/completed-scenario.xml</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial6.html#running-this-tutorial","title":"Running this Tutorial","text":"<p>This section will cover running this sample tutorial that develops a scenario file.</p> <ul> <li>Ensure that /opt/core/etc/core.conf has grpcaddress set to 0.0.0.0</li> <li>Make sure the core-daemon is running in a terminal     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial6.html#changing-node-icons","title":"Changing Node Icons","text":"<ul> <li> <p>Create three MDR nodes   <p> </p></p> </li> <li> <p>Double click on each node for configuration, click the icon and set it to use the drone.png image   <p> </p></p> </li> <li> <p>Use Session -&gt; Options and set Control Network 0 to 172.16.0.0./24</p> </li> </ul>"},{"location":"tutorials/tutorial6.html#linking-nodes-to-wlan","title":"Linking Nodes to WLAN","text":"<ul> <li>Add a WLAN Node</li> <li> <p>Link the three prior MDR nodes to the WLAN node   <p> </p></p> </li> <li> <p>Click play to start the scenario</p> </li> <li> <p>Observe wireless links being created   <p> </p></p> </li> <li> <p>Click stop to end the scenario</p> </li> <li>Right click the WLAN node and select Edit -&gt; Hide</li> <li>Now you can view the nodes in isolation   <p> </p> </li> </ul>"},{"location":"tutorials/tutorial6.html#changing-canvas-background","title":"Changing Canvas Background","text":"<ul> <li> <p>Click Canvas -&gt; Wallpaper to set the background to terrain.png   <p> </p></p> </li> <li> <p>Click play to start the scenario again</p> </li> <li>You now have a scenario with drone icons, terrain background, links displayed and hidden WLAN node   <p> </p> </li> </ul>"},{"location":"tutorials/tutorial6.html#adding-mobility","title":"Adding Mobility","text":"<ul> <li>Open and play the completed-scenario.xml</li> <li>Double click on n1 and run the demo.py script    <pre><code># node id is first parameter, second is total nodes\n/opt/core/venv/bin/python demo.py 1 3\n</code></pre></li> <li> <p>Let it run to see the link break as the node 1 drone approches the right side   <p> </p></p> </li> <li> <p>Repeat for other nodes, double click on n2 and n3 and run the demo.py script    <pre><code># n2\n/opt/core/venv/bin/python demo.py 2 3\n# n3\n/opt/core/venv/bin/python demo.py 3 3\n</code></pre></p> </li> <li>You can turn off wireless links via View -&gt; Wireless Links</li> <li>Observe nodes moving in parallel tracks, when the far right is reached, the node will move down   and then move to the left. When the far left is reached, the drone will move down and then move to the right.   <p> </p> </li> </ul>"},{"location":"tutorials/tutorial7.html","title":"Tutorial 7 - EMANE","text":""},{"location":"tutorials/tutorial7.html#overview","title":"Overview","text":"<p>This tutorial will cover basic usage and some concepts one may want to use or leverage when working with and creating EMANE based networks.</p> <p> </p> <p>For more detailed information on EMANE see the following:</p> <ul> <li>EMANE in CORE</li> <li>EMANE Wiki</li> </ul>"},{"location":"tutorials/tutorial7.html#files","title":"Files","text":"<p>Below is a list of the files used for this tutorial.</p> <ul> <li>2 node EMANE ieee80211abg scenario<ul> <li>/opt/core/share/tutorials/tutorial7/scenario.xml</li> <li>/opt/core/share/tutorials/tutorial7/scenario.py</li> </ul> </li> <li>2 node EMANE ieee80211abg scenario, with n2 running the \"Chat App Server\" service<ul> <li>/opt/core/share/tutorials/tutorial7/scenario_service.xml</li> <li>/opt/core/share/tutorials/tutorial7/scenario_service.py</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial7.html#running-this-tutorial","title":"Running this Tutorial","text":"<p>This section covers interactions that can be carried out for this scenario.</p> <p>Our scenario has the following nodes and addresses:</p> <ul> <li>emane1 - no address, this is a representative node for the EMANE network</li> <li>n2 - 10.0.0.1</li> <li>n3 - 10.0.0.2</li> </ul> <p>All usages below assume a clean scenario start.</p>"},{"location":"tutorials/tutorial7.html#using-ping","title":"Using Ping","text":"<p>Using the command line utility ping can be a good way to verify connectivity between nodes in CORE.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n2 by double clicking it in the GUI</p> </li> <li>Run the following in n2 terminal     <pre><code>ping -c 3 10.0.0.2\n</code></pre></li> <li>You should see the following output     <pre><code>PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=7.93 ms\n64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=3.07 ms\n64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=3.05 ms\n\n--- 10.0.0.2 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2000ms\nrtt min/avg/max/mdev = 3.049/4.685/7.932/2.295 ms\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial7.html#using-tcpdump","title":"Using Tcpdump","text":"<p>Using tcpdump can be very beneficial for examining a network. You can verify traffic being sent/received among many other uses.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n2 by double clicking it in the GUI</p> </li> <li>Open a terminal on n3 by double clicking it in the GUI</li> <li>Run the following in n3 terminal     <pre><code>tcpdump -lenni eth0\n</code></pre></li> <li>Run the following in n2 terminal     <pre><code>ping -c 1 10.0.0.2\n</code></pre></li> <li>You should see the following in n2 terminal     <pre><code>tcpdump: verbose output suppressed, use -v[v]... for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes\n14:56:25.414283 02:02:00:00:00:01 &gt; 02:02:00:00:00:02, ethertype IPv4 (0x0800), length 98: 10.0.0.1 &gt; 10.0.0.2: ICMP echo request, id 64832, seq 1, length 64\n14:56:25.414303 02:02:00:00:00:02 &gt; 02:02:00:00:00:01, ethertype IPv4 (0x0800), length 98: 10.0.0.2 &gt; 10.0.0.1: ICMP echo reply, id 64832, seq 1, length 64\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial7.html#running-software","title":"Running Software","text":"<p>We will now leverage the installed Chat App software to stand up a server and client within the nodes of our scenario.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n2 by double clicking it in the GUI</p> </li> <li>Run the following in n2 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-server\n</code></pre></li> <li>Open a terminal on n3 by double clicking it in the GUI</li> <li>Run the following in n3 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.1\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.1:44362 joining\n</code></pre></li> <li>Type the following in n2 terminal and hit enter     <pre><code>hello world\n</code></pre></li> <li>You will see the following output in n1 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.2:44362 joining\n[10.0.0.2:44362] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial7.html#tailing-a-log","title":"Tailing a Log","text":"<p>In this case we are using the service based scenario. This will automatically start and run the Chat App Server on n2 and log to a file. This case will demonstrate using <code>tail -f</code> to observe the output of running software.</p> <ul> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>In another terminal run the GUI     <pre><code>core-gui\n</code></pre></li> <li> <p>In the GUI menu bar select File-&gt;Open..., then navigate to and select scenario_service.xml <p> </p></p> </li> <li> <p>You can now click on the Start Session button to run the scenario   <p> </p></p> </li> <li> <p>Open a terminal on n2 by double clicking it in the GUI</p> </li> <li>Run the following in n2 terminal     <pre><code>tail -f chatapp.log\n</code></pre></li> <li>Open a terminal on n3 by double clicking it in the GUI</li> <li>Run the following in n3 terminal     <pre><code>export PATH=$PATH:/usr/local/bin\nchatapp-client -a 10.0.0.1\n</code></pre></li> <li>You will see the following output in n2 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.2:44362 joining\n</code></pre></li> <li>Type the following in n3 terminal and hit enter     <pre><code>hello world\n</code></pre></li> <li>You will see the following output in n2 terminal     <pre><code>chat server listening on: :9001\n[server] 10.0.0.2:44362 joining\n[10.0.0.2:44362] hello world\n</code></pre></li> </ul>"},{"location":"tutorials/tutorial7.html#advanced-topics","title":"Advanced Topics","text":"<p>This section will cover some high level topics and examples for running and using EMANE in CORE. You can find more detailed tutorials and examples at the EMANE Tutorial.</p> <p>Note</p> <p>Every topic below assumes CORE, EMANE, and OSPF MDR have been installed.</p> <p>Scenario files to support the EMANE topics below will be found in the GUI default directory for opening XML files.</p> Topic Model Description XML Files RF Pipe Overview of generated XML files used to drive EMANE GPSD RF Pipe Overview of running and integrating gpsd with EMANE Precomputed RF Pipe Overview of using the precomputed propagation model EEL RF Pipe Overview of using the Emulation Event Log (EEL) Generator Antenna Profiles RF Pipe Overview of using antenna profiles in EMANE"},{"location":"tutorials/tutorial7.html#grpc-python-scripts","title":"gRPC Python Scripts","text":"<p>You can also run the same steps above, using the provided gRPC script versions of scenarios. Below are the steps to run and join one of these scenario, then you can continue with the remaining steps of a given section.</p> <ol> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>From another terminal run the tutorial python script, which will create a session to join     <pre><code>/opt/core/venv/bin/python scenario.py\n</code></pre></li> <li>In another terminal run the CORE GUI     <pre><code>core-gui\n</code></pre></li> <li>You will be presented with sessions to join, select the one created by the script   <p> </p> </li> </ol>"},{"location":"tutorials/common/grpc.html","title":"Grpc","text":""},{"location":"tutorials/common/grpc.html#grpc-python-scripts","title":"gRPC Python Scripts","text":"<p>You can also run the same steps above, using the provided gRPC script versions of scenarios. Below are the steps to run and join one of these scenario, then you can continue with the remaining steps of a given section.</p> <ol> <li>Make sure the CORE daemon is running a terminal, if not already     <pre><code>sudo core-daemon\n</code></pre></li> <li>From another terminal run the tutorial python script, which will create a session to join     <pre><code>/opt/core/venv/bin/python scenario.py\n</code></pre></li> <li>In another terminal run the CORE GUI     <pre><code>core-gui\n</code></pre></li> <li>You will be presented with sessions to join, select the one created by the script   <p> </p> </li> </ol>"}]}